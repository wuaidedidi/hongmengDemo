/**
 * ğŸŒ APIæœåŠ¡ç±» (ApiService)
 * 
 * è¿™æ˜¯åº”ç”¨ä¸åç«¯æœåŠ¡é€šä¿¡çš„æ ¸å¿ƒç±»ï¼Œè´Ÿè´£å¤„ç†æ‰€æœ‰çš„HTTPè¯·æ±‚
 * é‡‡ç”¨å•ä¾‹æ¨¡å¼ï¼Œç¡®ä¿å…¨å±€åªæœ‰ä¸€ä¸ªAPIæœåŠ¡å®ä¾‹
 * 
 * ğŸ”¥ æ ¸å¿ƒåŠŸèƒ½ï¼š
 * - ç”¨æˆ·è®¤è¯ç®¡ç†ï¼ˆç™»å½•ã€æ³¨å†Œã€Tokenç®¡ç†ï¼‰
 * - å¾…åŠäº‹é¡¹CRUDæ“ä½œ
 * - ä¸“æ³¨ä¼šè¯ç®¡ç†
 * - ç»Ÿè®¡æ•°æ®è·å–
 * - è‡ªåŠ¨é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
 * 
 * ğŸ—ï¸ æ¶æ„ç‰¹ç‚¹ï¼š
 * - å•ä¾‹æ¨¡å¼ï¼šå…¨å±€ç»Ÿä¸€çš„APIæœåŠ¡å®ä¾‹
 * - JWTè®¤è¯ï¼šè‡ªåŠ¨å¤„ç†Tokenè®¤è¯
 * - é…ç½®çµæ´»ï¼šæ”¯æŒå¤šç¯å¢ƒé…ç½®
 * - æ•°æ®æŒä¹…åŒ–ï¼šæœ¬åœ°å­˜å‚¨ç”¨æˆ·ä¿¡æ¯
 */

import http from '@ohos.net.http';
import promptAction from '@ohos.promptAction';
import preferences from '@ohos.data.preferences';
import { ConfigService } from './ConfigService';

// ğŸ”§ é…ç½®å¸¸é‡
// const BASE_URL = 'http://10.0.2.2:8080/api'; // ç§»é™¤ç¡¬ç¼–ç ï¼Œæ”¹ä¸ºåŠ¨æ€é…ç½®
const PREFERENCES_NAME = 'dailyapp_preferences'; // æœ¬åœ°å­˜å‚¨é…ç½®åç§°
const TOKEN_KEY = 'auth_token';                  // Tokenå­˜å‚¨é”®
const USERNAME_KEY = 'username';                 // ç”¨æˆ·åå­˜å‚¨é”®

// ğŸ”— APIæ¥å£ç±»å‹å®šä¹‰
// è¿™äº›æ¥å£å®šä¹‰äº†ä¸åç«¯äº¤äº’çš„æ•°æ®ç»“æ„

/**
 * ğŸ‘¤ ç”¨æˆ·è®¤è¯å“åº”æ¥å£
 */
interface AuthResponse {
  token: string;    // JWTè®¤è¯ä»¤ç‰Œ
  username: string; // ç”¨æˆ·å
}

/**
 * â° ä¸“æ³¨ä¼šè¯è¯·æ±‚æ¥å£
 */
interface FocusSessionRequest {
  durationMinutes: number;  // ä¸“æ³¨æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
  startTime: string;        // å¼€å§‹æ—¶é—´
  endTime: string;          // ç»“æŸæ—¶é—´
  taskDescription: string;  // ä»»åŠ¡æè¿°
}

/**
 * ğŸ“Š ä¸“æ³¨ä¼šè¯æ•°æ®æ¥å£
 */
interface FocusSession {
  id: number;        // ä¼šè¯ID
  userId: number;    // ç”¨æˆ·ID
  duration: number;  // æŒç»­æ—¶é•¿
  startTime: string; // å¼€å§‹æ—¶é—´
  endTime: string;   // ç»“æŸæ—¶é—´
  type: string;      // ä¼šè¯ç±»å‹
}

/**
 * âŒ é”™è¯¯å“åº”æ¥å£
 */
interface ErrorResponse {
  message?: string; // é”™è¯¯æ¶ˆæ¯
  error?: string;   // é”™è¯¯è¯¦æƒ…
}

/**
 * âœ… ç­¾åˆ°æ•°æ®æ¥å£
 */
interface CheckIn {
  id: number;           // ç­¾åˆ°ID
  userId: number;       // ç”¨æˆ·ID
  checkInTime: string;  // ç­¾åˆ°æ—¶é—´
  streakCount: number;  // è¿ç»­ç­¾åˆ°å¤©æ•°
}

/**
 * ğŸ“ˆ ç»Ÿè®¡æ•°æ®å“åº”æ¥å£
 */
export interface StatisticsResponse {
  totalFocusTime: number;   // æ€»ä¸“æ³¨æ—¶é•¿
  totalFocusCount: number;  // æ€»ä¸“æ³¨æ¬¡æ•°
  continuousDays: number;   // è¿ç»­å¤©æ•°
  totalDays: number;        // æ€»å¤©æ•°
  todayFocusTime: number;   // ä»Šæ—¥ä¸“æ³¨æ—¶é•¿
  weeklyFocusTime: number;  // æœ¬å‘¨ä¸“æ³¨æ—¶é•¿
  monthlyFocusTime: number; // æœ¬æœˆä¸“æ³¨æ—¶é•¿
  currentStreak: number;    // å½“å‰è¿å‡»æ•°
}

// ğŸ“ å¾…åŠäº‹é¡¹ç›¸å…³æ¥å£å®šä¹‰

/**
 * å¾…åŠäº‹é¡¹åˆ›å»º/æ›´æ–°è¯·æ±‚æ¥å£
 */
export interface TodoItemRequest {
  title: string;          // å¾…åŠæ ‡é¢˜ï¼ˆå¿…å¡«ï¼‰
  description?: string;   // å¾…åŠæè¿°ï¼ˆå¯é€‰ï¼‰
  type: string;          // å¾…åŠåˆ†ç±»
  duration: number;      // é¢„è®¡æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
  isImportant?: boolean; // æ˜¯å¦é‡è¦
  isUrgent?: boolean;    // æ˜¯å¦ç´§æ€¥
}

/**
 * å¾…åŠäº‹é¡¹å®Œæ•´æ•°æ®æ¥å£
 */
export interface TodoItem {
  id: number;              // å¾…åŠID
  title: string;           // å¾…åŠæ ‡é¢˜
  description?: string;    // å¾…åŠæè¿°
  type: string;           // å¾…åŠåˆ†ç±»
  duration: number;       // é¢„è®¡æ—¶é•¿
  completed: boolean;     // å®ŒæˆçŠ¶æ€
  isImportant: boolean;   // é‡è¦æ€§æ ‡è®°
  isUrgent: boolean;      // ç´§æ€¥æ€§æ ‡è®°
  createdAt: string;      // åˆ›å»ºæ—¶é—´
  updatedAt?: string;     // æ›´æ–°æ—¶é—´
  userId: number;         // æ‰€å±ç”¨æˆ·ID
  focusTime?: number;     // å®é™…ä¸“æ³¨æ—¶é•¿
  completedTime?: string; // å®Œæˆæ—¶é—´
}

/**
 * ğŸ“‹ å¾…åŠåˆé›†æ¥å£
 */
export interface TodoCollection {
  id: number;           // åˆé›†ID
  title: string;        // åˆé›†æ ‡é¢˜
  description?: string; // åˆé›†æè¿°
  createdAt: string;    // åˆ›å»ºæ—¶é—´
  updatedAt?: string;   // æ›´æ–°æ—¶é—´
  userId: number;       // æ‰€å±ç”¨æˆ·ID
}

/**
 * ğŸ“‘ å¾…åŠåˆé›†å­é¡¹æ¥å£
 */
export interface TodoCollectionItem {
  id: number;               // å­é¡¹ID
  title: string;            // å­é¡¹æ ‡é¢˜
  description?: string;     // å­é¡¹æè¿°
  isCompleted: boolean;     // å®ŒæˆçŠ¶æ€
  orderIndex: number;       // æ’åºç´¢å¼•
  collectionId: number;     // æ‰€å±åˆé›†ID
  createTime: string;       // åˆ›å»ºæ—¶é—´
  durationMinutes?: number; // é¢„è®¡æ—¶é•¿
}

/**
 * å¾…åŠåˆé›†åˆ›å»ºè¯·æ±‚æ¥å£
 */
export interface TodoCollectionRequest {
  title: string;        // åˆé›†æ ‡é¢˜
  description?: string; // åˆé›†æè¿°
}

/**
 * å¾…åŠåˆé›†å­é¡¹åˆ›å»ºè¯·æ±‚æ¥å£
 */
export interface TodoCollectionItemRequest {
  title: string;            // å­é¡¹æ ‡é¢˜
  description?: string;     // å­é¡¹æè¿°
  durationMinutes?: number; // é¢„è®¡æ—¶é•¿
  orderIndex?: number;      // æ’åºç´¢å¼•
}

/**
 * ğŸŒ APIæœåŠ¡ç±» - æ ¸å¿ƒç½‘ç»œé€šä¿¡æœåŠ¡
 * 
 * é‡‡ç”¨å•ä¾‹æ¨¡å¼è®¾è®¡ï¼Œç¡®ä¿å…¨åº”ç”¨åªæœ‰ä¸€ä¸ªAPIæœåŠ¡å®ä¾‹
 * è´Ÿè´£å¤„ç†æ‰€æœ‰ä¸åç«¯çš„HTTPé€šä¿¡
 */
export class ApiService {
  /** å•ä¾‹å®ä¾‹ */
  private static instance: ApiService;
  
  /** JWTè®¤è¯ä»¤ç‰Œ */
  private token: string = '';
  
  /** æœ¬åœ°å­˜å‚¨æœåŠ¡ */
  private preferences: preferences.Preferences | null = null;
  
  /** åˆå§‹åŒ–Promiseï¼Œç¡®ä¿æœåŠ¡å®Œå…¨åˆå§‹åŒ–åå†ä½¿ç”¨ */
  private initPromise: Promise<void> | null = null;
  
  /** é…ç½®æœåŠ¡å®ä¾‹ */
  private configService: ConfigService = ConfigService.getInstance();
  
  /** APIåŸºç¡€URL */
  private baseUrl: string = '';

  /**
   * ç§æœ‰æ„é€ å‡½æ•° - å®ç°å•ä¾‹æ¨¡å¼
   * åœ¨æ„é€ æ—¶å¯åŠ¨å¼‚æ­¥åˆå§‹åŒ–è¿‡ç¨‹
   */
  private constructor() {
    this.initPromise = this.initPreferences();
  }

  private async initPreferences() {
    try {
      // åˆå§‹åŒ–é…ç½®æœåŠ¡
      await this.configService.initialize();
      this.baseUrl = this.configService.getApiBaseUrl();
      console.info('âœ… API Base URL:', this.baseUrl);

      const context = getContext(this);
      this.preferences = await preferences.getPreferences(context, PREFERENCES_NAME);
      // ä»æœ¬åœ°å­˜å‚¨åŠ è½½token
      this.token = await this.preferences.get(TOKEN_KEY, '') as string;
      console.info('Token loaded from preferences:', this.token ? 'Token exists' : 'No token');
    } catch (error) {
      console.error('âŒ åˆå§‹åŒ–å¤±è´¥:', error);
      // è®¾ç½®é»˜è®¤APIåœ°å€ä½œä¸ºfallback
      this.baseUrl = 'http://8.148.20.194:8080/api';
      console.warn('âš ï¸ ä½¿ç”¨é»˜è®¤APIåœ°å€ä½œä¸ºfallback:', this.baseUrl);
    }
  }

  static getInstance(): ApiService {
    if (!ApiService.instance) {
      ApiService.instance = new ApiService();
    }
    return ApiService.instance;
  }

  private async ensureInitialized() {
    if (this.initPromise) {
      await this.initPromise;
      this.initPromise = null;
    }
  }

  private ensureBaseUrl() {
    if (!this.baseUrl) {
      this.baseUrl = 'http://8.148.20.194:8080/api';
      console.warn('âš ï¸ BaseUrlä¸ºç©ºï¼Œä½¿ç”¨é»˜è®¤å€¼:', this.baseUrl);
    }
  }

  async setToken(token: string) {
    await this.ensureInitialized();
    this.token = token;
    if (this.preferences) {
      try {
        await this.preferences.put(TOKEN_KEY, token);
        await this.preferences.flush();
        console.info('Token saved to preferences');
      } catch (error) {
        console.error('ä¿å­˜tokenå¤±è´¥:', error);
      }
    }
  }

  async setUsername(username: string) {
    await this.ensureInitialized();
    if (this.preferences) {
      try {
        await this.preferences.put(USERNAME_KEY, username);
        await this.preferences.flush();
      } catch (error) {
        console.error('ä¿å­˜ç”¨æˆ·åå¤±è´¥:', error);
      }
    }
  }

  async getUsername(): Promise<string> {
    await this.ensureInitialized();
    if (this.preferences) {
      try {
        return await this.preferences.get(USERNAME_KEY, '') as string;
      } catch (error) {
        console.error('è·å–ç”¨æˆ·åå¤±è´¥:', error);
      }
    }
    return '';
  }

  async getToken(): Promise<string> {
    await this.ensureInitialized();
    if (this.preferences) {
      try {
        return await this.preferences.get(TOKEN_KEY, '') as string;
      } catch (error) {
        console.error('è·å–tokenå¤±è´¥:', error);
      }
    }
    return '';
  }

  async clearAuth() {
    await this.ensureInitialized();
    this.token = '';
    if (this.preferences) {
      try {
        await this.preferences.delete(TOKEN_KEY);
        await this.preferences.delete(USERNAME_KEY);
        await this.preferences.flush();
        console.info('Auth cleared from preferences');
      } catch (error) {
        console.error('æ¸…é™¤è®¤è¯ä¿¡æ¯å¤±è´¥:', error);
      }
    }
  }

  private async getHeaders(): Promise<Record<string, string>> {
    const headers: Record<string, string> = {};
    headers['Content-Type'] = 'application/json';
    
    try {
      const token: string = await this.getToken();
      console.log('ğŸ” è·å–åˆ°çš„token:', token ? (token.substring(0, 20) + '...') : 'null');
      if (token) {
        headers['Authorization'] = `Bearer ${token}`;
        console.log('âœ… å·²æ·»åŠ Authorizationå¤´');
      } else {
        console.warn('âš ï¸ æ²¡æœ‰æ‰¾åˆ°tokenï¼Œå¯èƒ½æœªç™»å½•');
      }
    } catch (error) {
      console.error('âŒ è·å–tokenå¤±è´¥:', error);
    }
    
    return headers;
  }

  async login(username: string, password: string): Promise<AuthResponse> {
    try {
      await this.ensureInitialized();
      this.ensureBaseUrl();
      
      console.info(`å°è¯•ç™»å½•: username=${username}`);
      console.info(`è¯·æ±‚URL: ${this.baseUrl}/auth/login`);
      const headers = await this.getHeaders();
      console.info(`è¯·æ±‚å¤´: ${JSON.stringify(headers)}`);
      console.info(`è¯·æ±‚æ•°æ®: ${JSON.stringify({ username, password })}`);

      let httpRequest = http.createHttp();
      let response = await httpRequest.request(
        `${this.baseUrl}/auth/login`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify({ username, password })
        }
      );
      console.info(`ç™»å½•å“åº”: code=${response.responseCode}, result=${response.result}`);
      console.info(`å“åº”å¤´: ${JSON.stringify(response.header)}`);

      if (response.responseCode === 200) {
        const data = JSON.parse(response.result as string) as AuthResponse;
        return data;
      } else {
        console.error(`ç™»å½•å¤±è´¥: code=${response.responseCode}, result=${response.result}`);
        throw new Error(`HTTP ${response.responseCode}: ${response.result}`);
      }
    } catch (error) {
      console.error('ç™»å½•è¯·æ±‚å¤±è´¥:', error);
      console.error('é”™è¯¯ç±»å‹:', typeof error);
      console.error('é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));
      throw new Error((error as Error).message);
    }
  }

  async register(username: string, password: string): Promise<AuthResponse> {
    try {
      await this.ensureInitialized();
      this.ensureBaseUrl();
      
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/auth/register`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify({ username, password })
        }
      );
      if (response.responseCode === 200) {
        const data = JSON.parse(response.result as string) as AuthResponse;
        this.setToken(data.token);
        return data;
      } else {
        throw new Error('æ³¨å†Œå¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'æ³¨å†Œå¤±è´¥ï¼š' + (error as Error).message });
      throw new Error('æ³¨å†Œå¤±è´¥');
    }
  }

  async createFocusSession(sessionData: FocusSessionRequest): Promise<FocusSession> {
    try {
      await this.ensureInitialized();
      this.ensureBaseUrl();
      
      console.info('å‘é€ä¸“æ³¨ä¼šè¯è¯·æ±‚:', JSON.stringify(sessionData));
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      console.info('è¯·æ±‚å¤´:', JSON.stringify(headers));
      
      let response = await httpRequest.request(
        `${this.baseUrl}/sessions`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify(sessionData)
        }
      );
      
      console.info(`å“åº”çŠ¶æ€ç : ${response.responseCode}`);
      console.info(`å“åº”å†…å®¹: ${response.result}`);
      
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as FocusSession;
      } else {
        let errorMessage = 'åˆ›å»ºä¸“æ³¨æ—¶æ®µå¤±è´¥';
        try {
          const errorResponse: ErrorResponse = JSON.parse(response.result as string);
          if (errorResponse.message) {
            errorMessage = errorResponse.message;
          } else if (errorResponse.error) {
            errorMessage = errorResponse.error;
          }
        } catch (parseError) {
          errorMessage = `HTTP ${response.responseCode}: ${response.result}`;
        }
        throw new Error(errorMessage);
      }
    } catch (error) {
      console.error('åˆ›å»ºä¸“æ³¨ä¼šè¯å¤±è´¥:', error);
      const errorMessage = (error as Error).message || 'ç½‘ç»œè¯·æ±‚å¤±è´¥';
      promptAction.showToast({ message: 'åˆ›å»ºä¸“æ³¨æ—¶æ®µå¤±è´¥ï¼š' + errorMessage });
      throw new Error(errorMessage);
    }
  }

  async getDailySessions(date: string): Promise<FocusSession[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/sessions/daily?date=${date}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as FocusSession[];
      } else {
        throw new Error('è·å–æ¯æ—¥ç»Ÿè®¡å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'è·å–æ¯æ—¥ç»Ÿè®¡å¤±è´¥ï¼š' + (error as Error).message });
      throw new Error('è·å–æ¯æ—¥ç»Ÿè®¡å¤±è´¥');
    }
  }

  async getWeeklySessions(weekStart: string): Promise<FocusSession[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/sessions/weekly?weekStart=${weekStart}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as FocusSession[];
      } else {
        throw new Error('è·å–å‘¨ç»Ÿè®¡å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'è·å–å‘¨ç»Ÿè®¡å¤±è´¥ï¼š' + (error as Error).message });
      throw new Error('è·å–å‘¨ç»Ÿè®¡å¤±è´¥');
    }
  }

  async getMonthlySessions(monthStart: string): Promise<FocusSession[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/sessions/monthly?monthStart=${monthStart}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as FocusSession[];
      } else {
        throw new Error('è·å–æœˆç»Ÿè®¡å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'è·å–æœˆç»Ÿè®¡å¤±è´¥ï¼š' + (error as Error).message });
      throw new Error('è·å–æœˆç»Ÿè®¡å¤±è´¥');
    }
  }

  async getStatistics(): Promise<StatisticsResponse> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/sessions/statistics`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as StatisticsResponse;
      } else {
        throw new Error('è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥');
      }
    } catch (error) {
      console.error('è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥:', error);
      throw new Error('è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async checkIn(): Promise<CheckIn> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/check-in`,
        {
          method: http.RequestMethod.POST,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as CheckIn;
      } else {
        throw new Error('æ‰“å¡å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'æ‰“å¡å¤±è´¥ï¼š' + (error as Error).message });
      throw new Error('æ‰“å¡å¤±è´¥');
    }
  }

  async getCurrentStreak(): Promise<number> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/check-in/streak`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as number;
      } else {
        throw new Error('è·å–è¿ç»­æ‰“å¡å¤©æ•°å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'è·å–è¿ç»­æ‰“å¡å¤©æ•°å¤±è´¥ï¼š' + (error as Error).message });
      return 0;
    }
  }

  async hasCheckedInToday(): Promise<boolean> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/check-in/today`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as boolean;
      } else {
        throw new Error('æ£€æŸ¥ä»Šæ—¥æ‰“å¡çŠ¶æ€å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'æ£€æŸ¥ä»Šæ—¥æ‰“å¡çŠ¶æ€å¤±è´¥ï¼š' + (error as Error).message });
      return false;
    }
  }

  // Todoç›¸å…³æ–¹æ³•å®ç°
  async createTodoItem(todoData: TodoItemRequest): Promise<TodoItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify(todoData)
        }
      );
      if (response.responseCode === 200 || response.responseCode === 201) {
        return JSON.parse(response.result as string) as TodoItem;
      } else {
        throw new Error('åˆ›å»ºå¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ›å»ºå¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('åˆ›å»ºå¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async getTodoItems(): Promise<TodoItem[]> {
    try {
      console.log('ğŸ” å¼€å§‹è·å–å¾…åŠäº‹é¡¹...');
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      console.log('ğŸ” è¯·æ±‚å¤´:', JSON.stringify(headers));
      console.log('ğŸ” è¯·æ±‚URL:', `${this.baseUrl}/todos`);
      
      let response = await httpRequest.request(
        `${this.baseUrl}/todos`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      
      console.log('ğŸ” å“åº”çŠ¶æ€ç :', response.responseCode);
      console.log('ğŸ” å“åº”å†…å®¹:', response.result);
      
      if (response.responseCode === 200) {
        const todos = JSON.parse(response.result as string) as TodoItem[];
        console.log('âœ… æˆåŠŸè·å–å¾…åŠäº‹é¡¹ï¼Œæ•°é‡:', todos.length);
        return todos;
      } else {
        console.error('âŒ è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼ŒçŠ¶æ€ç :', response.responseCode);
        throw new Error('è·å–å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('âŒ è·å–å¾…åŠäº‹é¡¹å¼‚å¸¸:', error);
      throw new Error('è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async toggleTodoItemStatus(todoId: number): Promise<TodoItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/${todoId}/toggle`,
        {
          method: http.RequestMethod.PUT,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem;
      } else {
        throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹çŠ¶æ€å¤±è´¥');
      }
    } catch (error) {
      console.error('æ›´æ–°å¾…åŠäº‹é¡¹çŠ¶æ€å¤±è´¥:', error);
      throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹çŠ¶æ€å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async deleteTodoItem(todoId: number): Promise<void> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/${todoId}`,
        {
          method: http.RequestMethod.DELETE,
          header: headers
        }
      );
      if (response.responseCode !== 200 && response.responseCode !== 204) {
        throw new Error('åˆ é™¤å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ é™¤å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('åˆ é™¤å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æŒ‰çŠ¶æ€è·å–å¾…åŠäº‹é¡¹
  async getTodoItemsByStatus(isCompleted: boolean): Promise<TodoItem[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/status/${isCompleted}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem[];
      } else {
        throw new Error('æŒ‰çŠ¶æ€è·å–å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('æŒ‰çŠ¶æ€è·å–å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('æŒ‰çŠ¶æ€è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æŒ‰ç±»å‹è·å–å¾…åŠäº‹é¡¹
  async getTodoItemsByType(type: string): Promise<TodoItem[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/type/${type}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem[];
      } else {
        throw new Error('æŒ‰ç±»å‹è·å–å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('æŒ‰ç±»å‹è·å–å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('æŒ‰ç±»å‹è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æŒ‰æ—¥æœŸèŒƒå›´è·å–å¾…åŠäº‹é¡¹
  async getTodoItemsInDateRange(startDate: string, endDate: string): Promise<TodoItem[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/date-range?startDate=${startDate}&endDate=${endDate}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem[];
      } else {
        throw new Error('æŒ‰æ—¥æœŸèŒƒå›´è·å–å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('æŒ‰æ—¥æœŸèŒƒå›´è·å–å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('æŒ‰æ—¥æœŸèŒƒå›´è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // è·å–å•ä¸ªå¾…åŠäº‹é¡¹
  async getTodoItem(todoId: number): Promise<TodoItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/${todoId}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem;
      } else {
        throw new Error('è·å–å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('è·å–å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æ›´æ–°å¾…åŠäº‹é¡¹
  async updateTodoItem(todoId: number, todoData: TodoItemRequest): Promise<TodoItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/${todoId}`,
        {
          method: http.RequestMethod.PUT,
          header: headers,
          extraData: JSON.stringify(todoData)
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem;
      } else {
        throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('æ›´æ–°å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æ›´æ–°å¾…åŠäº‹é¡¹çš„ä¸“æ³¨æ—¶é—´
  async updateTodoItemFocusTime(todoId: number, focusTime: number): Promise<TodoItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/${todoId}/focus-time`,
        {
          method: http.RequestMethod.PUT,
          header: headers,
          extraData: JSON.stringify({ focusTime })
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem;
      } else {
        throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹ä¸“æ³¨æ—¶é—´å¤±è´¥');
      }
    } catch (error) {
      console.error('æ›´æ–°å¾…åŠäº‹é¡¹ä¸“æ³¨æ—¶é—´å¤±è´¥:', error);
      throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹ä¸“æ³¨æ—¶é—´å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async createTodoCollection(collectionData: TodoCollectionRequest): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify(collectionData)
        }
      );
      if (response.responseCode === 200 || response.responseCode === 201) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æ–°å¢æ–¹æ³•ï¼šç›´æ¥æ¥å—å­—ç¬¦ä¸²å‚æ•°ï¼Œé¿å…ç»“æ„åŒ–ç±»å‹é—®é¢˜
  async createTodoCollectionDirect(title: string, description?: string): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      
      // ç›´æ¥æ„é€ JSONå­—ç¬¦ä¸²ï¼Œé¿å…å¯¹è±¡å­—é¢é‡ï¼Œä½¿ç”¨titleå­—æ®µ
      const requestBody = description 
        ? `{"title":"${title}","description":"${description}"}`
        : `{"title":"${title}"}`;
      
      console.info('å‘é€å¾…åŠåˆé›†è¯·æ±‚:', requestBody);
      
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: requestBody
        }
      );
      
      console.info(`å¾…åŠåˆé›†åˆ›å»ºå“åº”çŠ¶æ€ç : ${response.responseCode}`);
      console.info(`å¾…åŠåˆé›†åˆ›å»ºå“åº”å†…å®¹: ${response.result}`);
      
      if (response.responseCode === 200 || response.responseCode === 201) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        let errorMessage = 'åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥';
        try {
          const errorResponse: ErrorResponse = JSON.parse(response.result as string);
          if (errorResponse.message) {
            errorMessage = errorResponse.message;
          } else if (errorResponse.error) {
            errorMessage = errorResponse.error;
          }
        } catch (parseError) {
          errorMessage = `HTTP ${response.responseCode}: ${response.result}`;
        }
        throw new Error(errorMessage);
      }
    } catch (error) {
      console.error('åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async getTodoCollections(): Promise<TodoCollection[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection[];
      } else {
        throw new Error('è·å–å¾…åŠåˆé›†å¤±è´¥');
      }
    } catch (error) {
      console.error('è·å–å¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('è·å–å¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async deleteTodoCollection(collectionId: number): Promise<void> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}`,
        {
          method: http.RequestMethod.DELETE,
          header: headers
        }
      );
      if (response.responseCode !== 200 && response.responseCode !== 204) {
        throw new Error('åˆ é™¤å¾…åŠåˆé›†å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ é™¤å¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('åˆ é™¤å¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // è·å–å•ä¸ªå¾…åŠåˆé›†
  async getTodoCollection(collectionId: number): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('è·å–å¾…åŠåˆé›†å¤±è´¥');
      }
    } catch (error) {
      console.error('è·å–å¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('è·å–å¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // è·å–åˆé›†é¡¹ç›®
  async getCollectionItems(collectionId: number): Promise<TodoCollectionItem[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/items`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollectionItem[];
      } else {
        throw new Error('è·å–åˆé›†é¡¹ç›®å¤±è´¥');
      }
    } catch (error) {
      console.error('è·å–åˆé›†é¡¹ç›®å¤±è´¥:', error);
      throw new Error('è·å–åˆé›†é¡¹ç›®å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æ›´æ–°å¾…åŠåˆé›†
  async updateTodoCollection(collectionId: number, collectionData: TodoCollectionRequest): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}`,
        {
          method: http.RequestMethod.PUT,
          header: headers,
          extraData: JSON.stringify(collectionData)
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('æ›´æ–°å¾…åŠåˆé›†å¤±è´¥');
      }
    } catch (error) {
      console.error('æ›´æ–°å¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('æ›´æ–°å¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æ·»åŠ é¡¹ç›®åˆ°åˆé›†
  async addItemToCollection(collectionId: number, itemData: TodoCollectionItemRequest): Promise<TodoCollectionItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/items`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify(itemData)
        }
      );
      if (response.responseCode === 200 || response.responseCode === 201) {
        return JSON.parse(response.result as string) as TodoCollectionItem;
      } else {
        throw new Error('æ·»åŠ åˆé›†é¡¹ç›®å¤±è´¥');
      }
    } catch (error) {
      console.error('æ·»åŠ åˆé›†é¡¹ç›®å¤±è´¥:', error);
      throw new Error('æ·»åŠ åˆé›†é¡¹ç›®å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // åˆ‡æ¢åˆé›†é¡¹ç›®çŠ¶æ€
  async toggleCollectionItemStatus(collectionId: number, itemId: number): Promise<TodoCollectionItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/items/${itemId}/toggle`,
        {
          method: http.RequestMethod.PUT,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollectionItem;
      } else {
        throw new Error('åˆ‡æ¢åˆé›†é¡¹ç›®çŠ¶æ€å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ‡æ¢åˆé›†é¡¹ç›®çŠ¶æ€å¤±è´¥:', error);
      throw new Error('åˆ‡æ¢åˆé›†é¡¹ç›®çŠ¶æ€å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // å¼€å§‹åºåˆ—
  async startSequence(collectionId: number): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/sequence/start`,
        {
          method: http.RequestMethod.PUT,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('å¼€å§‹åºåˆ—å¤±è´¥');
      }
    } catch (error) {
      console.error('å¼€å§‹åºåˆ—å¤±è´¥:', error);
      throw new Error('å¼€å§‹åºåˆ—å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // åœæ­¢åºåˆ—
  async stopSequence(collectionId: number): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/sequence/stop`,
        {
          method: http.RequestMethod.PUT,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('åœæ­¢åºåˆ—å¤±è´¥');
      }
    } catch (error) {
      console.error('åœæ­¢åºåˆ—å¤±è´¥:', error);
      throw new Error('åœæ­¢åºåˆ—å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // ä¸‹ä¸€ä¸ªä»»åŠ¡åºåˆ—
  async nextTaskInSequence(collectionId: number): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/sequence/next`,
        {
          method: http.RequestMethod.PUT,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('ä¸‹ä¸€ä¸ªä»»åŠ¡å¤±è´¥');
      }
    } catch (error) {
      console.error('ä¸‹ä¸€ä¸ªä»»åŠ¡å¤±è´¥:', error);
      throw new Error('ä¸‹ä¸€ä¸ªä»»åŠ¡å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // åˆ é™¤åˆé›†é¡¹ç›®
  async deleteCollectionItem(collectionId: number, itemId: number): Promise<void> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/items/${itemId}`,
        {
          method: http.RequestMethod.DELETE,
          header: headers
        }
      );
      if (response.responseCode !== 200 && response.responseCode !== 204) {
        throw new Error('åˆ é™¤åˆé›†é¡¹ç›®å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ é™¤åˆé›†é¡¹ç›®å¤±è´¥:', error);
      throw new Error('åˆ é™¤åˆé›†é¡¹ç›®å¤±è´¥ï¼š' + (error as Error).message);
    }
  }
}