import http from '@ohos.net.http';
import promptAction from '@ohos.promptAction';
import preferences from '@ohos.data.preferences';
import { ConfigService } from './ConfigService';

// const BASE_URL = 'http://10.0.2.2:8080/api'; // ç§»é™¤ç¡¬ç¼–ç 
const PREFERENCES_NAME = 'dailyapp_preferences';
const TOKEN_KEY = 'auth_token';
const USERNAME_KEY = 'username';

// å®šä¹‰æ¥å£ç±»å‹
interface AuthResponse {
  token: string;
  username: string;
}

interface FocusSessionRequest {
  durationMinutes: number;
  startTime: string;
  endTime: string;
  taskDescription: string;
}

interface FocusSession {
  id: number;
  userId: number;
  duration: number;
  startTime: string;
  endTime: string;
  type: string;
}

interface ErrorResponse {
  message?: string;
  error?: string;
}

interface CheckIn {
  id: number;
  userId: number;
  checkInTime: string;
  streakCount: number;
}

export interface StatisticsResponse {
  totalFocusTime: number;
  totalFocusCount: number;
  continuousDays: number;
  totalDays: number;
  todayFocusTime: number;
  weeklyFocusTime: number;
  monthlyFocusTime: number;
  currentStreak: number;
}

// æ·»åŠ Todoç›¸å…³æ¥å£
export interface TodoItemRequest {
  title: string;
  description?: string;
  type: string;
  duration: number;
  isImportant?: boolean;
  isUrgent?: boolean;
}

export interface TodoItem {
  id: number;
  title: string;
  description?: string;
  type: string;
  duration: number;
  completed: boolean;
  isImportant: boolean;
  isUrgent: boolean;
  createdAt: string;
  updatedAt?: string;
  userId: number;
  focusTime?: number;
  completedTime?: string;
}

export interface TodoCollection {
  id: number;
  title: string;
  description?: string;
  createdAt: string;
  updatedAt?: string;
  userId: number;
}

export interface TodoCollectionItem {
  id: number;
  title: string;
  description?: string;
  isCompleted: boolean;
  orderIndex: number;
  collectionId: number;
  createTime: string;
  durationMinutes?: number;
}

export interface TodoCollectionRequest {
  title: string;
  description?: string;
}

export interface TodoCollectionItemRequest {
  title: string;
  description?: string;
  durationMinutes?: number;
  orderIndex?: number;
}

export class ApiService {
  private static instance: ApiService;
  private token: string = '';
  private preferences: preferences.Preferences | null = null;
  private initPromise: Promise<void> | null = null;
  private configService: ConfigService = ConfigService.getInstance();
  private baseUrl: string = '';

  private constructor() {
    this.initPromise = this.initPreferences();
  }

  private async initPreferences() {
    try {
      // åˆå§‹åŒ–é…ç½®æœåŠ¡
      await this.configService.initialize();
      this.baseUrl = this.configService.getApiBaseUrl();
      console.info('API Base URL:', this.baseUrl);

      const context = getContext(this);
      this.preferences = await preferences.getPreferences(context, PREFERENCES_NAME);
      // ä»æœ¬åœ°å­˜å‚¨åŠ è½½token
      this.token = await this.preferences.get(TOKEN_KEY, '') as string;
      console.info('Token loaded from preferences:', this.token ? 'Token exists' : 'No token');
    } catch (error) {
      console.error('åˆå§‹åŒ–æœ¬åœ°å­˜å‚¨å¤±è´¥:', error);
    }
  }

  static getInstance(): ApiService {
    if (!ApiService.instance) {
      ApiService.instance = new ApiService();
    }
    return ApiService.instance;
  }

  private async ensureInitialized() {
    if (this.initPromise) {
      await this.initPromise;
      this.initPromise = null;
    }
  }

  async setToken(token: string) {
    await this.ensureInitialized();
    this.token = token;
    if (this.preferences) {
      try {
        await this.preferences.put(TOKEN_KEY, token);
        await this.preferences.flush();
        console.info('Token saved to preferences');
      } catch (error) {
        console.error('ä¿å­˜tokenå¤±è´¥:', error);
      }
    }
  }

  async setUsername(username: string) {
    await this.ensureInitialized();
    if (this.preferences) {
      try {
        await this.preferences.put(USERNAME_KEY, username);
        await this.preferences.flush();
      } catch (error) {
        console.error('ä¿å­˜ç”¨æˆ·åå¤±è´¥:', error);
      }
    }
  }

  async getUsername(): Promise<string> {
    await this.ensureInitialized();
    if (this.preferences) {
      try {
        return await this.preferences.get(USERNAME_KEY, '') as string;
      } catch (error) {
        console.error('è·å–ç”¨æˆ·åå¤±è´¥:', error);
      }
    }
    return '';
  }

  async getToken(): Promise<string> {
    await this.ensureInitialized();
    if (this.preferences) {
      try {
        return await this.preferences.get(TOKEN_KEY, '') as string;
      } catch (error) {
        console.error('è·å–tokenå¤±è´¥:', error);
      }
    }
    return '';
  }

  async clearAuth() {
    await this.ensureInitialized();
    this.token = '';
    if (this.preferences) {
      try {
        await this.preferences.delete(TOKEN_KEY);
        await this.preferences.delete(USERNAME_KEY);
        await this.preferences.flush();
        console.info('Auth cleared from preferences');
      } catch (error) {
        console.error('æ¸…é™¤è®¤è¯ä¿¡æ¯å¤±è´¥:', error);
      }
    }
  }

  private async getHeaders(): Promise<Record<string, string>> {
    const headers: Record<string, string> = {};
    headers['Content-Type'] = 'application/json';
    
    try {
      const token: string = await this.getToken();
      console.log('ğŸ” è·å–åˆ°çš„token:', token ? (token.substring(0, 20) + '...') : 'null');
      if (token) {
        headers['Authorization'] = `Bearer ${token}`;
        console.log('âœ… å·²æ·»åŠ Authorizationå¤´');
      } else {
        console.warn('âš ï¸ æ²¡æœ‰æ‰¾åˆ°tokenï¼Œå¯èƒ½æœªç™»å½•');
      }
    } catch (error) {
      console.error('âŒ è·å–tokenå¤±è´¥:', error);
    }
    
    return headers;
  }

  async login(username: string, password: string): Promise<AuthResponse> {
    try {
      console.info(`å°è¯•ç™»å½•: username=${username}`);
      console.info(`è¯·æ±‚URL: ${this.baseUrl}/auth/login`);
      const headers = await this.getHeaders();
      console.info(`è¯·æ±‚å¤´: ${JSON.stringify(headers)}`);
      console.info(`è¯·æ±‚æ•°æ®: ${JSON.stringify({ username, password })}`);

      let httpRequest = http.createHttp();
      let response = await httpRequest.request(
        `${this.baseUrl}/auth/login`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify({ username, password })
        }
      );
      console.info(`ç™»å½•å“åº”: code=${response.responseCode}, result=${response.result}`);
      console.info(`å“åº”å¤´: ${JSON.stringify(response.header)}`);

      if (response.responseCode === 200) {
        const data = JSON.parse(response.result as string) as AuthResponse;
        return data;
      } else {
        console.error(`ç™»å½•å¤±è´¥: code=${response.responseCode}, result=${response.result}`);
        throw new Error(`HTTP ${response.responseCode}: ${response.result}`);
      }
    } catch (error) {
      console.error('ç™»å½•è¯·æ±‚å¤±è´¥:', error);
      console.error('é”™è¯¯ç±»å‹:', typeof error);
      console.error('é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));
      throw new Error((error as Error).message);
    }
  }

  async register(username: string, password: string): Promise<AuthResponse> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/auth/register`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify({ username, password })
        }
      );
      if (response.responseCode === 200) {
        const data = JSON.parse(response.result as string) as AuthResponse;
        this.setToken(data.token);
        return data;
      } else {
        throw new Error('æ³¨å†Œå¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'æ³¨å†Œå¤±è´¥ï¼š' + (error as Error).message });
      throw new Error('æ³¨å†Œå¤±è´¥');
    }
  }

  async createFocusSession(sessionData: FocusSessionRequest): Promise<FocusSession> {
    try {
      console.info('å‘é€ä¸“æ³¨ä¼šè¯è¯·æ±‚:', JSON.stringify(sessionData));
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      console.info('è¯·æ±‚å¤´:', JSON.stringify(headers));
      
      let response = await httpRequest.request(
        `${this.baseUrl}/sessions`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify(sessionData)
        }
      );
      
      console.info(`å“åº”çŠ¶æ€ç : ${response.responseCode}`);
      console.info(`å“åº”å†…å®¹: ${response.result}`);
      
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as FocusSession;
      } else {
        let errorMessage = 'åˆ›å»ºä¸“æ³¨æ—¶æ®µå¤±è´¥';
        try {
          const errorResponse: ErrorResponse = JSON.parse(response.result as string);
          if (errorResponse.message) {
            errorMessage = errorResponse.message;
          } else if (errorResponse.error) {
            errorMessage = errorResponse.error;
          }
        } catch (parseError) {
          errorMessage = `HTTP ${response.responseCode}: ${response.result}`;
        }
        throw new Error(errorMessage);
      }
    } catch (error) {
      console.error('åˆ›å»ºä¸“æ³¨ä¼šè¯å¤±è´¥:', error);
      const errorMessage = (error as Error).message || 'ç½‘ç»œè¯·æ±‚å¤±è´¥';
      promptAction.showToast({ message: 'åˆ›å»ºä¸“æ³¨æ—¶æ®µå¤±è´¥ï¼š' + errorMessage });
      throw new Error(errorMessage);
    }
  }

  async getDailySessions(date: string): Promise<FocusSession[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/sessions/daily?date=${date}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as FocusSession[];
      } else {
        throw new Error('è·å–æ¯æ—¥ç»Ÿè®¡å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'è·å–æ¯æ—¥ç»Ÿè®¡å¤±è´¥ï¼š' + (error as Error).message });
      throw new Error('è·å–æ¯æ—¥ç»Ÿè®¡å¤±è´¥');
    }
  }

  async getWeeklySessions(weekStart: string): Promise<FocusSession[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/sessions/weekly?weekStart=${weekStart}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as FocusSession[];
      } else {
        throw new Error('è·å–å‘¨ç»Ÿè®¡å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'è·å–å‘¨ç»Ÿè®¡å¤±è´¥ï¼š' + (error as Error).message });
      throw new Error('è·å–å‘¨ç»Ÿè®¡å¤±è´¥');
    }
  }

  async getMonthlySessions(monthStart: string): Promise<FocusSession[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/sessions/monthly?monthStart=${monthStart}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as FocusSession[];
      } else {
        throw new Error('è·å–æœˆç»Ÿè®¡å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'è·å–æœˆç»Ÿè®¡å¤±è´¥ï¼š' + (error as Error).message });
      throw new Error('è·å–æœˆç»Ÿè®¡å¤±è´¥');
    }
  }

  async getStatistics(): Promise<StatisticsResponse> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/sessions/statistics`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as StatisticsResponse;
      } else {
        throw new Error('è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥');
      }
    } catch (error) {
      console.error('è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥:', error);
      throw new Error('è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async checkIn(): Promise<CheckIn> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/check-in`,
        {
          method: http.RequestMethod.POST,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as CheckIn;
      } else {
        throw new Error('æ‰“å¡å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'æ‰“å¡å¤±è´¥ï¼š' + (error as Error).message });
      throw new Error('æ‰“å¡å¤±è´¥');
    }
  }

  async getCurrentStreak(): Promise<number> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/check-in/streak`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as number;
      } else {
        throw new Error('è·å–è¿ç»­æ‰“å¡å¤©æ•°å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'è·å–è¿ç»­æ‰“å¡å¤©æ•°å¤±è´¥ï¼š' + (error as Error).message });
      return 0;
    }
  }

  async hasCheckedInToday(): Promise<boolean> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/check-in/today`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as boolean;
      } else {
        throw new Error('æ£€æŸ¥ä»Šæ—¥æ‰“å¡çŠ¶æ€å¤±è´¥');
      }
    } catch (error) {
      promptAction.showToast({ message: 'æ£€æŸ¥ä»Šæ—¥æ‰“å¡çŠ¶æ€å¤±è´¥ï¼š' + (error as Error).message });
      return false;
    }
  }

  // Todoç›¸å…³æ–¹æ³•å®ç°
  async createTodoItem(todoData: TodoItemRequest): Promise<TodoItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify(todoData)
        }
      );
      if (response.responseCode === 200 || response.responseCode === 201) {
        return JSON.parse(response.result as string) as TodoItem;
      } else {
        throw new Error('åˆ›å»ºå¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ›å»ºå¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('åˆ›å»ºå¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async getTodoItems(): Promise<TodoItem[]> {
    try {
      console.log('ğŸ” å¼€å§‹è·å–å¾…åŠäº‹é¡¹...');
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      console.log('ğŸ” è¯·æ±‚å¤´:', JSON.stringify(headers));
      console.log('ğŸ” è¯·æ±‚URL:', `${this.baseUrl}/todos`);
      
      let response = await httpRequest.request(
        `${this.baseUrl}/todos`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      
      console.log('ğŸ” å“åº”çŠ¶æ€ç :', response.responseCode);
      console.log('ğŸ” å“åº”å†…å®¹:', response.result);
      
      if (response.responseCode === 200) {
        const todos = JSON.parse(response.result as string) as TodoItem[];
        console.log('âœ… æˆåŠŸè·å–å¾…åŠäº‹é¡¹ï¼Œæ•°é‡:', todos.length);
        return todos;
      } else {
        console.error('âŒ è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼ŒçŠ¶æ€ç :', response.responseCode);
        throw new Error('è·å–å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('âŒ è·å–å¾…åŠäº‹é¡¹å¼‚å¸¸:', error);
      throw new Error('è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async toggleTodoItemStatus(todoId: number): Promise<TodoItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/${todoId}/toggle`,
        {
          method: http.RequestMethod.PUT,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem;
      } else {
        throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹çŠ¶æ€å¤±è´¥');
      }
    } catch (error) {
      console.error('æ›´æ–°å¾…åŠäº‹é¡¹çŠ¶æ€å¤±è´¥:', error);
      throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹çŠ¶æ€å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async deleteTodoItem(todoId: number): Promise<void> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/${todoId}`,
        {
          method: http.RequestMethod.DELETE,
          header: headers
        }
      );
      if (response.responseCode !== 200 && response.responseCode !== 204) {
        throw new Error('åˆ é™¤å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ é™¤å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('åˆ é™¤å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æŒ‰çŠ¶æ€è·å–å¾…åŠäº‹é¡¹
  async getTodoItemsByStatus(isCompleted: boolean): Promise<TodoItem[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/status/${isCompleted}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem[];
      } else {
        throw new Error('æŒ‰çŠ¶æ€è·å–å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('æŒ‰çŠ¶æ€è·å–å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('æŒ‰çŠ¶æ€è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æŒ‰ç±»å‹è·å–å¾…åŠäº‹é¡¹
  async getTodoItemsByType(type: string): Promise<TodoItem[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/type/${type}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem[];
      } else {
        throw new Error('æŒ‰ç±»å‹è·å–å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('æŒ‰ç±»å‹è·å–å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('æŒ‰ç±»å‹è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æŒ‰æ—¥æœŸèŒƒå›´è·å–å¾…åŠäº‹é¡¹
  async getTodoItemsInDateRange(startDate: string, endDate: string): Promise<TodoItem[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/date-range?startDate=${startDate}&endDate=${endDate}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem[];
      } else {
        throw new Error('æŒ‰æ—¥æœŸèŒƒå›´è·å–å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('æŒ‰æ—¥æœŸèŒƒå›´è·å–å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('æŒ‰æ—¥æœŸèŒƒå›´è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // è·å–å•ä¸ªå¾…åŠäº‹é¡¹
  async getTodoItem(todoId: number): Promise<TodoItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/${todoId}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem;
      } else {
        throw new Error('è·å–å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('è·å–å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('è·å–å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æ›´æ–°å¾…åŠäº‹é¡¹
  async updateTodoItem(todoId: number, todoData: TodoItemRequest): Promise<TodoItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/${todoId}`,
        {
          method: http.RequestMethod.PUT,
          header: headers,
          extraData: JSON.stringify(todoData)
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem;
      } else {
        throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹å¤±è´¥');
      }
    } catch (error) {
      console.error('æ›´æ–°å¾…åŠäº‹é¡¹å¤±è´¥:', error);
      throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æ›´æ–°å¾…åŠäº‹é¡¹çš„ä¸“æ³¨æ—¶é—´
  async updateTodoItemFocusTime(todoId: number, focusTime: number): Promise<TodoItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todos/${todoId}/focus-time`,
        {
          method: http.RequestMethod.PUT,
          header: headers,
          extraData: JSON.stringify({ focusTime })
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoItem;
      } else {
        throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹ä¸“æ³¨æ—¶é—´å¤±è´¥');
      }
    } catch (error) {
      console.error('æ›´æ–°å¾…åŠäº‹é¡¹ä¸“æ³¨æ—¶é—´å¤±è´¥:', error);
      throw new Error('æ›´æ–°å¾…åŠäº‹é¡¹ä¸“æ³¨æ—¶é—´å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async createTodoCollection(collectionData: TodoCollectionRequest): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify(collectionData)
        }
      );
      if (response.responseCode === 200 || response.responseCode === 201) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æ–°å¢æ–¹æ³•ï¼šç›´æ¥æ¥å—å­—ç¬¦ä¸²å‚æ•°ï¼Œé¿å…ç»“æ„åŒ–ç±»å‹é—®é¢˜
  async createTodoCollectionDirect(title: string, description?: string): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      
      // ç›´æ¥æ„é€ JSONå­—ç¬¦ä¸²ï¼Œé¿å…å¯¹è±¡å­—é¢é‡ï¼Œä½¿ç”¨titleå­—æ®µ
      const requestBody = description 
        ? `{"title":"${title}","description":"${description}"}`
        : `{"title":"${title}"}`;
      
      console.info('å‘é€å¾…åŠåˆé›†è¯·æ±‚:', requestBody);
      
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: requestBody
        }
      );
      
      console.info(`å¾…åŠåˆé›†åˆ›å»ºå“åº”çŠ¶æ€ç : ${response.responseCode}`);
      console.info(`å¾…åŠåˆé›†åˆ›å»ºå“åº”å†…å®¹: ${response.result}`);
      
      if (response.responseCode === 200 || response.responseCode === 201) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        let errorMessage = 'åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥';
        try {
          const errorResponse: ErrorResponse = JSON.parse(response.result as string);
          if (errorResponse.message) {
            errorMessage = errorResponse.message;
          } else if (errorResponse.error) {
            errorMessage = errorResponse.error;
          }
        } catch (parseError) {
          errorMessage = `HTTP ${response.responseCode}: ${response.result}`;
        }
        throw new Error(errorMessage);
      }
    } catch (error) {
      console.error('åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('åˆ›å»ºå¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async getTodoCollections(): Promise<TodoCollection[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection[];
      } else {
        throw new Error('è·å–å¾…åŠåˆé›†å¤±è´¥');
      }
    } catch (error) {
      console.error('è·å–å¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('è·å–å¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  async deleteTodoCollection(collectionId: number): Promise<void> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}`,
        {
          method: http.RequestMethod.DELETE,
          header: headers
        }
      );
      if (response.responseCode !== 200 && response.responseCode !== 204) {
        throw new Error('åˆ é™¤å¾…åŠåˆé›†å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ é™¤å¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('åˆ é™¤å¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // è·å–å•ä¸ªå¾…åŠåˆé›†
  async getTodoCollection(collectionId: number): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('è·å–å¾…åŠåˆé›†å¤±è´¥');
      }
    } catch (error) {
      console.error('è·å–å¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('è·å–å¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // è·å–åˆé›†é¡¹ç›®
  async getCollectionItems(collectionId: number): Promise<TodoCollectionItem[]> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/items`,
        {
          method: http.RequestMethod.GET,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollectionItem[];
      } else {
        throw new Error('è·å–åˆé›†é¡¹ç›®å¤±è´¥');
      }
    } catch (error) {
      console.error('è·å–åˆé›†é¡¹ç›®å¤±è´¥:', error);
      throw new Error('è·å–åˆé›†é¡¹ç›®å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æ›´æ–°å¾…åŠåˆé›†
  async updateTodoCollection(collectionId: number, collectionData: TodoCollectionRequest): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}`,
        {
          method: http.RequestMethod.PUT,
          header: headers,
          extraData: JSON.stringify(collectionData)
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('æ›´æ–°å¾…åŠåˆé›†å¤±è´¥');
      }
    } catch (error) {
      console.error('æ›´æ–°å¾…åŠåˆé›†å¤±è´¥:', error);
      throw new Error('æ›´æ–°å¾…åŠåˆé›†å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // æ·»åŠ é¡¹ç›®åˆ°åˆé›†
  async addItemToCollection(collectionId: number, itemData: TodoCollectionItemRequest): Promise<TodoCollectionItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/items`,
        {
          method: http.RequestMethod.POST,
          header: headers,
          extraData: JSON.stringify(itemData)
        }
      );
      if (response.responseCode === 200 || response.responseCode === 201) {
        return JSON.parse(response.result as string) as TodoCollectionItem;
      } else {
        throw new Error('æ·»åŠ åˆé›†é¡¹ç›®å¤±è´¥');
      }
    } catch (error) {
      console.error('æ·»åŠ åˆé›†é¡¹ç›®å¤±è´¥:', error);
      throw new Error('æ·»åŠ åˆé›†é¡¹ç›®å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // åˆ‡æ¢åˆé›†é¡¹ç›®çŠ¶æ€
  async toggleCollectionItemStatus(collectionId: number, itemId: number): Promise<TodoCollectionItem> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/items/${itemId}/toggle`,
        {
          method: http.RequestMethod.PUT,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollectionItem;
      } else {
        throw new Error('åˆ‡æ¢åˆé›†é¡¹ç›®çŠ¶æ€å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ‡æ¢åˆé›†é¡¹ç›®çŠ¶æ€å¤±è´¥:', error);
      throw new Error('åˆ‡æ¢åˆé›†é¡¹ç›®çŠ¶æ€å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // å¼€å§‹åºåˆ—
  async startSequence(collectionId: number): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/sequence/start`,
        {
          method: http.RequestMethod.PUT,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('å¼€å§‹åºåˆ—å¤±è´¥');
      }
    } catch (error) {
      console.error('å¼€å§‹åºåˆ—å¤±è´¥:', error);
      throw new Error('å¼€å§‹åºåˆ—å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // åœæ­¢åºåˆ—
  async stopSequence(collectionId: number): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/sequence/stop`,
        {
          method: http.RequestMethod.PUT,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('åœæ­¢åºåˆ—å¤±è´¥');
      }
    } catch (error) {
      console.error('åœæ­¢åºåˆ—å¤±è´¥:', error);
      throw new Error('åœæ­¢åºåˆ—å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // ä¸‹ä¸€ä¸ªä»»åŠ¡åºåˆ—
  async nextTaskInSequence(collectionId: number): Promise<TodoCollection> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/sequence/next`,
        {
          method: http.RequestMethod.PUT,
          header: headers
        }
      );
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string) as TodoCollection;
      } else {
        throw new Error('ä¸‹ä¸€ä¸ªä»»åŠ¡å¤±è´¥');
      }
    } catch (error) {
      console.error('ä¸‹ä¸€ä¸ªä»»åŠ¡å¤±è´¥:', error);
      throw new Error('ä¸‹ä¸€ä¸ªä»»åŠ¡å¤±è´¥ï¼š' + (error as Error).message);
    }
  }

  // åˆ é™¤åˆé›†é¡¹ç›®
  async deleteCollectionItem(collectionId: number, itemId: number): Promise<void> {
    try {
      let httpRequest = http.createHttp();
      const headers = await this.getHeaders();
      let response = await httpRequest.request(
        `${this.baseUrl}/todo-collections/${collectionId}/items/${itemId}`,
        {
          method: http.RequestMethod.DELETE,
          header: headers
        }
      );
      if (response.responseCode !== 200 && response.responseCode !== 204) {
        throw new Error('åˆ é™¤åˆé›†é¡¹ç›®å¤±è´¥');
      }
    } catch (error) {
      console.error('åˆ é™¤åˆé›†é¡¹ç›®å¤±è´¥:', error);
      throw new Error('åˆ é™¤åˆé›†é¡¹ç›®å¤±è´¥ï¼š' + (error as Error).message);
    }
  }
}