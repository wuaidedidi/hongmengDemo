import router from '@ohos.router';
import promptAction from '@ohos.promptAction';
import common from '@ohos.app.ability.common';
import wantConstant from '@ohos.ability.wantConstant';
import bundleManager from '@ohos.bundle.bundleManager';
import type Want from '@ohos.app.ability.Want';
import { TodoCollection, TodoItem, TodoStatus } from '../model/TodoTypes';
import { mockCollections } from '../model/MockData';
import { TabBar } from '../components/TabBar';
import { ThemeService, ThemeConfig, DEFAULT_THEME_CONFIG } from '../services/ThemeService';
import { ActualTodoItem, LocalTodoCollection } from '../model/TodoDetailTypes';
import { AddTodoDialog, AddCollectionDialog, PermissionDialog, AddSubTaskDialog } from '../components/dialogs/TodoDialogs';
import { 
  TodoDetailRouterParams, 
  TodoItemDisplay, 
  RouterError, 
  FocusTimerRouterParams 
} from '../types/CommonTypes';










@Entry
@Component
struct TodoDetail {
  @State collections: LocalTodoCollection[] = [];
  @State currentExpandedId: string | null = null;
  @State currentIndex: number = 1;
  @State bgColor: string = 'rgba(173, 216, 230, 0.15)';
  @State showCongratulationsDialog: boolean = false;
  @State currentTheme: ThemeConfig = DEFAULT_THEME_CONFIG;
  @State todoCollections: LocalTodoCollection[] = [
    new LocalTodoCollection("default_coll1", "å­¦ä¹ é¸¿è’™å¼€å‘", [
      new ActualTodoItem("s1_1", "é˜…è¯»å®˜æ–¹æ–‡æ¡£ç¬¬ä¸€ç« ", 25),
      new ActualTodoItem("s1_2", "å®Œæˆå…¥é—¨Demo", 45),
      new ActualTodoItem("s1_3", "å­¦ä¹ UIç»„ä»¶", 60)
    ]),
    new LocalTodoCollection("default_coll2", "å®¶åº­æ¸…æ´ä»»åŠ¡", [
      new ActualTodoItem("s2_1", "æ‰“æ‰«å®¢å…", 20),
      new ActualTodoItem("s2_2", "æ¸…æ´—å¨æˆ¿", 30),
      new ActualTodoItem("s2_3", "æ•´ç†å§å®¤", 25)
    ])
  ];
  private nextCollectionIdSuffix: number = 3;
  @State newCollectionTitle: string = '';
  private addCollectionDialogController: CustomDialogController | null = null;
  private addSubTaskDialogController: CustomDialogController | null = null;
  private themeService = ThemeService.getInstance();

  private themeChangeListener = async () => {
    try {
      this.currentTheme = await this.themeService.getCurrentTheme();
    } catch (error) {
      console.error('TodoDetailä¸»é¢˜æ›´æ–°å¤±è´¥:', error);
    }
  };

  async aboutToAppear() {
    console.info('TodoDetail aboutToAppear. CurrentIndex: ' + this.currentIndex);
    this.currentIndex = 1;
    this.themeService.addThemeChangeListener(this.themeChangeListener);
    // é¦–å…ˆåŠ è½½ä¿å­˜çš„ä¸»é¢˜åå¥½è®¾ç½®
    await this.themeService.loadThemePreference();
    this.currentTheme = await this.themeService.getCurrentTheme();
    this.processRouteParams(); // å¤„ç†é¦–æ¬¡è¿›å…¥æ—¶å¯èƒ½å­˜åœ¨çš„è·¯ç”±å‚æ•°
  }

  aboutToDisappear() {
    this.themeService.removeThemeChangeListener(this.themeChangeListener);
  }

  onPageShow() {
    console.info("TodoDetail page onPageShow triggered");
    this.currentIndex = 1;
    this.processRouteParams(); // å¤„ç†æ¯æ¬¡é¡µé¢æ˜¾ç¤ºæ—¶çš„è·¯ç”±å‚æ•°
  }

  processRouteParams() {
    const params = router.getParams() as TodoDetailRouterParams;
    if (!params || Object.keys(params).length === 0) {
      console.info('TodoDetail: No route params to process.');
      return;
    }
    console.info('TodoDetail router.getParams(): ' + JSON.stringify(params));

    this.handleRouterParams(params);
  }

  handleRouterParams(params: TodoDetailRouterParams) {
    if (!params) return;

    const collectionId = params.collectionId ? String(params.collectionId) : null;
    const subTaskId = params.subTaskId ? String(params.subTaskId) : null;

    if (!collectionId) return;

    const collectionIndex = this.todoCollections.findIndex(c => c.id === collectionId);
    if (collectionIndex === -1) return;

    const collection = this.todoCollections[collectionIndex];

    if (params.sequenceAction === 'taskCompleted' && subTaskId) {
      const taskIndex = collection.subTasks.findIndex(st => st.id === subTaskId);
      if (taskIndex !== -1) {
        // æ ‡è®°å½“å‰ä»»åŠ¡ä¸ºå®Œæˆ
        collection.subTasks[taskIndex].isCompleted = true;
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡éƒ½å·²å®Œæˆ
        const allSubTasksDone = collection.subTasks.every(st => st.isCompleted);
        if (allSubTasksDone) {
          collection.isSequenceActive = false;
          collection.currentTaskIndex = -1;
          this.showCongratulationsDialog = true;
          setTimeout(() => {
            this.showCongratulationsDialog = false;
          }, 5000);
          promptAction.showToast({ message: `æ­å–œï¼åˆé›† "${collection.collectionTitle}" å·²å…¨éƒ¨å®Œæˆï¼` });
        } else {
          // åºåˆ—æœªå®Œæˆï¼Œè‡ªåŠ¨å¯åŠ¨ä¸‹ä¸€ä¸ªä»»åŠ¡
          let nextUncompletedTaskIndex = -1;
          for (let i = taskIndex + 1; i < collection.subTasks.length; i++) {
            if (!collection.subTasks[i].isCompleted) {
              nextUncompletedTaskIndex = i;
              break;
            }
          }
          if (nextUncompletedTaskIndex !== -1) {
            collection.currentTaskIndex = nextUncompletedTaskIndex;
            this.startSequenceTask(collection, nextUncompletedTaskIndex);
          } else {
            collection.isSequenceActive = false;
            collection.currentTaskIndex = -1;
          }
        }
      }
    } else if (params.sequenceAction === 'sequenceAborted') {
      collection.isSequenceActive = false;
      collection.currentTaskIndex = -1;
      promptAction.showToast({ message: `åºåˆ— '${collection.collectionTitle}' å·²ä¸­æ­¢` });
    } else if (params.action === 'focusCompleted' && subTaskId) {
      const taskIndex = collection.subTasks.findIndex(st => st.id === subTaskId);
      if (taskIndex !== -1) {
        collection.subTasks[taskIndex].isCompleted = true;
        promptAction.showToast({ message: `ä»»åŠ¡ '${collection.subTasks[taskIndex].title}' å·²å®Œæˆ` });
      }
    }

    // æ›´æ–°UI
    const updatedCollection = new LocalTodoCollection(
      collection.id, 
      collection.collectionTitle, 
      collection.subTasks,
      collection.isExpanded
    );
    updatedCollection.isSequenceActive = collection.isSequenceActive;
    updatedCollection.currentTaskIndex = collection.currentTaskIndex;
    this.todoCollections.splice(collectionIndex, 1, updatedCollection);
    this.todoCollections = Array.from(this.todoCollections);
  }

  // åŠ¨æ€åˆ›å»ºæ·»åŠ åˆé›†å¼¹çª—
  async openAddCollectionDialog() {
    try {
      this.newCollectionTitle = '';
      const currentTheme = await this.themeService.getCurrentTheme();
      
      this.addCollectionDialogController = new CustomDialogController({
        builder: AddCollectionDialog({
          collectionTitle: this.newCollectionTitle,
          currentTheme: currentTheme,
          onConfirm: (title: string) => {
            this.newCollectionTitle = title;
            this.addNewCollection();
          }
        }),
        autoCancel: true,
        alignment: DialogAlignment.Center,
        customStyle: true,
        maskColor: Color.Transparent
      });
      this.addCollectionDialogController.open();
    } catch (error) {
      console.error('æ‰“å¼€æ·»åŠ åˆé›†å¼¹çª—å¤±è´¥:', error);
    }
  }

  // åŠ¨æ€åˆ›å»ºæ·»åŠ å­ä»»åŠ¡å¼¹çª—
  async openAddSubTaskDialog() {
    try {
      const currentTheme = await this.themeService.getCurrentTheme();
      
      this.addSubTaskDialogController = new CustomDialogController({
        builder: AddSubTaskDialog({
          currentTheme: currentTheme,
          onConfirm: (title: string, duration: number) => {
            this.addNewSubTask(title, duration);
          }
        }),
        autoCancel: true,
        alignment: DialogAlignment.Center,
        customStyle: true,
        maskColor: Color.Transparent
      });
      this.addSubTaskDialogController.open();
    } catch (error) {
      console.error('æ‰“å¼€æ·»åŠ å­ä»»åŠ¡å¼¹çª—å¤±è´¥:', error);
    }
  }

  addNewCollection() {
    if (this.newCollectionTitle.trim() === '') {
      promptAction.showToast({ message: "åˆé›†åç§°ä¸èƒ½ä¸ºç©º" });
      return;
    }
    const newId = "coll_" + Date.now().toString() + '_' + this.nextCollectionIdSuffix++;
    const defaultSubTasks = [
      new ActualTodoItem(newId + '_s1', "æ–°å­ä»»åŠ¡1 (ç¼–è¾‘æˆ‘)", 10),
      new ActualTodoItem(newId + '_s2', "æ–°å­ä»»åŠ¡2 (ç¼–è¾‘æˆ‘)", 15)
    ];
    const newCollection = new LocalTodoCollection(newId, this.newCollectionTitle.trim(), defaultSubTasks);
    this.todoCollections.push(newCollection);
    this.newCollectionTitle = '';
    promptAction.showToast({ message: "æ–°å¾…åŠåˆé›†å·²æ·»åŠ " });
  }

  startSequenceTask(collection: LocalTodoCollection, startIndex: number = 0) {
    if (!collection || collection.subTasks.length === 0) {
      promptAction.showToast({ message: `åˆé›† "${collection?.collectionTitle}" ä¸­æ²¡æœ‰ä»»åŠ¡ã€‚` });
      return;
    }

    // æ£€æŸ¥ä»startIndexå¼€å§‹æ˜¯å¦è¿˜æœ‰æœªå®Œæˆçš„ä»»åŠ¡
    let nextTaskIndex = -1;
    for (let i = startIndex; i < collection.subTasks.length; i++) {
      if (!collection.subTasks[i].isCompleted) {
        nextTaskIndex = i;
        break;
      }
    }

    if (nextTaskIndex === -1) {
      // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡éƒ½å·²å®Œæˆ
      const allDone = collection.subTasks.every(st => st.isCompleted);
      if (allDone) {
        this.showCongratulationsDialog = true;
        setTimeout(() => {
          this.showCongratulationsDialog = false;
        }, 5000);
        promptAction.showToast({ message: `å¤ªæ£’äº†ï¼åˆé›† "${collection.collectionTitle}" å·²å…¨éƒ¨å®Œæˆï¼` });
      } else {
        promptAction.showToast({ message: `åˆé›† "${collection.collectionTitle}" ä¸­ä»å½“å‰ä½ç½®å¼€å§‹æ²¡æœ‰æœªå®Œæˆçš„ä»»åŠ¡ã€‚` });
      }
      collection.isSequenceActive = false;
      collection.currentTaskIndex = -1;
      const colIndex = this.todoCollections.findIndex(c => c.id === collection.id);
      if (colIndex !== -1) {
        const updatedCollection = new LocalTodoCollection(
          collection.id, 
          collection.collectionTitle, 
          collection.subTasks,
          collection.isExpanded
        );
        updatedCollection.isSequenceActive = collection.isSequenceActive;
        updatedCollection.currentTaskIndex = collection.currentTaskIndex;
        this.todoCollections.splice(colIndex, 1, updatedCollection);
      }
      this.todoCollections = Array.from(this.todoCollections);
      return;
    }

    collection.isSequenceActive = true;
    collection.currentTaskIndex = nextTaskIndex;
    const subTask = collection.subTasks[nextTaskIndex];

    const colIdx = this.todoCollections.findIndex(c => c.id === collection.id);
    if (colIdx !== -1) {
      const updatedCollection = new LocalTodoCollection(
        collection.id, 
        collection.collectionTitle, 
        collection.subTasks,
        collection.isExpanded
      );
      updatedCollection.isSequenceActive = collection.isSequenceActive;
      updatedCollection.currentTaskIndex = collection.currentTaskIndex;
      this.todoCollections.splice(colIdx, 1, updatedCollection);
    }
    this.todoCollections = Array.from(this.todoCollections);

    const params: FocusTimerRouterParams = {
      title: subTask.title,
      taskTitle: `${collection.collectionTitle} - ${subTask.title}`,
      time: subTask.durationMinutes * 60,
      isSequence: true,
      collectionId: collection.id,
      subTaskId: subTask.id,
      currentSubTaskIndex: nextTaskIndex,
      totalSubTasksInCollection: collection.subTasks.length
    };

    router.pushUrl({ url: 'pages/FocusTimer', params: params })
      .catch((err: RouterError) => {
        console.error(`Error navigating to FocusTimer for sequence: ${JSON.stringify(err)}`);
        promptAction.showToast({ message: `å¯åŠ¨åºåˆ—ä»»åŠ¡å¤±è´¥: ${err.message}` });
        collection.isSequenceActive = false;
        collection.currentTaskIndex = -1;
        const cIdx = this.todoCollections.findIndex(c => c.id === collection.id);
        if (cIdx !== -1) {
          const updatedCollection = new LocalTodoCollection(
            collection.id, 
            collection.collectionTitle, 
            collection.subTasks,
            collection.isExpanded
          );
          updatedCollection.isSequenceActive = collection.isSequenceActive;
          updatedCollection.currentTaskIndex = collection.currentTaskIndex;
          this.todoCollections.splice(cIdx, 1, updatedCollection);
        }
        this.todoCollections = Array.from(this.todoCollections);
      });
  }

  // æ·»åŠ ä¸€ä¸ªå¤„ç†å±•å¼€/æ”¶èµ·çš„æ–¹æ³•
  toggleExpand(collection: LocalTodoCollection) {
    const index = this.todoCollections.findIndex(c => c.id === collection.id);
    if (index === -1) return;

    // åˆ›å»ºæ–°çš„é›†åˆå®ä¾‹ï¼Œä¿æŒæ‰€æœ‰çŠ¶æ€
    const updatedCollection = new LocalTodoCollection(
      collection.id,
      collection.collectionTitle,
      collection.subTasks,
      !collection.isExpanded // åˆ‡æ¢å±•å¼€çŠ¶æ€
    );
    updatedCollection.isSequenceActive = collection.isSequenceActive;
    updatedCollection.currentTaskIndex = collection.currentTaskIndex;

    // æ›´æ–°é›†åˆ
    this.todoCollections.splice(index, 1, updatedCollection);
    this.todoCollections = Array.from(this.todoCollections);
  }

  @Builder
  TodoItemBuilder(item: TodoItemDisplay) {
    Row() {
      Column() {
        Text(item.title)
          .fontSize(16)
          .fontWeight(FontWeight.Medium)
        if (item.description) {
          Text(item.description)
            .fontSize(14)
            .opacity(0.6)
            .margin({ top: 4 })
        }
      }.layoutWeight(1)

      if (item.isImportant || item.isUrgent) {
        Row() {
          if (item.isImportant) {
            Text('é‡è¦')
              .fontSize(12)
              .fontColor('#FF4500')
              .backgroundColor('#FFE4E1')
              .padding({
                left: 8,
                right: 8,
                top: 2,
                bottom: 2
              })
              .borderRadius(4)
              .margin({ right: 8 })
          }
          if (item.isUrgent) {
            Text('ç´§æ€¥')
              .fontSize(12)
              .fontColor('#FF0000')
              .backgroundColor('#FFF0F0')
              .padding({
                left: 8,
                right: 8,
                top: 2,
                bottom: 2
              })
              .borderRadius(4)
          }
        }
      }

      Text(item.status === TodoStatus.COMPLETED ? 'âœ“' :
        (item.status === TodoStatus.IN_PROGRESS ? 'â³' : ''))
        .fontSize(20)
        .fontColor(item.status === TodoStatus.COMPLETED ? '#4CAF50' : '#FFA500')
        .margin({ left: 8 })
    }
    .width('100%')
    .padding(16)
    .backgroundColor('#FFFFFF')
    .borderRadius(8)
    .onClick(() => {
      router.pushUrl({
        url: 'pages/FocusTimer',
        params: {
          taskTitle: item.title,
          time: 25 * 60
        }
      }).catch((err: RouterError) => {
        console.error('å¯¼èˆªåˆ°ä¸“æ³¨é¡µé¢å¤±è´¥:', err.message);
      });
    })
  }

  // è·å–åº”ç”¨ä¸Šä¸‹æ–‡
  getAppAbilityContext(): common.UIAbilityContext | undefined {
    const context = getContext(this);
    if (context && typeof context === 'object') {
      try {
        const uiContext = context as common.UIAbilityContext;
        if (uiContext.applicationInfo !== undefined && typeof uiContext.startAbility === 'function') {
          return uiContext;
        }
      } catch (e) {
        console.error("Context conversion to UIAbilityContext error: " + ((e as Error).message || String(e)));
      }
    }
    console.warn("Failed to get a valid UIAbilityContext.");
    return undefined;
  }

  // è·³è½¬åˆ°ç³»ç»Ÿåº”ç”¨æƒé™è®¾ç½®é¡µé¢
  startSystemSettingsGuidanceFlow() {
    const context = this.getAppAbilityContext();
    if (!context) {
      promptAction.showToast({ message: "æ— æ³•è·å–åº”ç”¨ä¸Šä¸‹æ–‡" });
      return;
    }

    try {
      // å°è¯•ç›´æ¥è·³è½¬åˆ°åº”ç”¨æƒé™è®¾ç½®é¡µé¢
      const want: Want = {
        bundleName: 'com.ohos.settings',
        abilityName: 'com.ohos.settings.MainAbility',
        parameters: {
          SETTINGS_PARAM_TYPE: 'PERMISSION_MANAGER',
          SETTINGS_PARAM_BUNDLE_NAME: context.applicationInfo?.name || '',
          SETTINGS_PARAM_PERMISSION_NAME: 'ALL'
        }
      };

      context.startAbility(want)
        .then(() => {
          console.info('Successfully launched settings page');
        })
        .catch((err: Error) => {
          console.error(`Failed to launch settings page: ${err.message}`);
          // å¦‚æœç›´æ¥è·³è½¬å¤±è´¥ï¼Œå°è¯•è·³è½¬åˆ°åº”ç”¨ç®¡ç†é¡µé¢
          const alternativeWant: Want = {
            bundleName: 'com.ohos.settings',
            abilityName: 'com.ohos.settings.MainAbility',
            parameters: {
              SETTINGS_PARAM_TYPE: 'APP_MANAGEMENT',
              SETTINGS_PARAM_BUNDLE_NAME: context.applicationInfo?.name || ''
            }
          };
          
          return context.startAbility(alternativeWant);
        })
        .catch((err: Error) => {
          console.error(`Failed to launch alternative settings page: ${err.message}`);
          // å¦‚æœè¿˜æ˜¯å¤±è´¥ï¼Œå°è¯•è·³è½¬åˆ°ç³»ç»Ÿè®¾ç½®ä¸»é¡µ
          const fallbackWant: Want = {
            bundleName: 'com.ohos.settings',
            abilityName: 'com.ohos.settings.MainAbility'
          };
          
          return context.startAbility(fallbackWant);
        })
        .catch((err: Error) => {
          console.error(`All attempts to launch settings failed: ${err.message}`);
          promptAction.showToast({ message: "æ— æ³•æ‰“å¼€è®¾ç½®é¡µé¢ï¼Œè¯·æ‰‹åŠ¨å‰å¾€ç³»ç»Ÿè®¾ç½®>åº”ç”¨ç®¡ç†>æœ¬åº”ç”¨>æƒé™ç®¡ç†" });
        });
    } catch (error) {
      console.error(`Error launching settings: ${(error as Error).message || String(error)}`);
      promptAction.showToast({ message: "æ‰“å¼€è®¾ç½®é¡µé¢æ—¶å‡ºé”™ï¼Œè¯·æ‰‹åŠ¨è®¾ç½®æƒé™" });
    }
  }

  // æ·»åŠ æ–°å­ä»»åŠ¡çš„æ–¹æ³•
  addNewSubTask(title: string, duration: number) {
    const collection = this.todoCollections.find(c => c.id === this.currentExpandedId);
    if (collection) {
      const newTaskId = collection.id + '_s' + (collection.subTasks.length + 1);
      const newTask = new ActualTodoItem(newTaskId, title, duration);
      collection.subTasks.push(newTask);
      
      // æ›´æ–°é›†åˆ
      const index = this.todoCollections.findIndex(c => c.id === collection.id);
      if (index !== -1) {
        const updatedCollection = new LocalTodoCollection(
          collection.id,
          collection.collectionTitle,
          collection.subTasks,
          collection.isExpanded
        );
        updatedCollection.isSequenceActive = collection.isSequenceActive;
        updatedCollection.currentTaskIndex = collection.currentTaskIndex;
        this.todoCollections.splice(index, 1, updatedCollection);
        this.todoCollections = Array.from(this.todoCollections);
      }
      
      promptAction.showToast({ message: "æ–°å­ä»»åŠ¡å·²æ·»åŠ " });
    }
  }

  build() {
    Stack() {
      Column().width('100%').height('100%').backgroundColor(this.currentTheme.backgroundColor)
        Column() {
          Row() {
            Text('å¾…åŠäº‹é¡¹')
            .fontSize(22).fontWeight(FontWeight.Bold).fontColor(Color.White)
            Blank()
          Row({ space: 16 }) {
            Row() {
              Text('å¿…å¼€').fontSize(14).fontColor(Color.White)
              Text('æƒé™').fontSize(14).fontColor(Color.White)
            }
            .backgroundColor('rgba(255, 255, 255, 0.2)')
            .borderRadius(12).padding({ left: 8, right: 8, top: 4, bottom: 4 })
            .margin({ right: 4 })
            .onClick(() => { this.startSystemSettingsGuidanceFlow(); })
            Text('+').fontSize(24).fontColor(Color.White)
              .onClick(() => {
                this.openAddCollectionDialog();
              })
            Text('â‰¡').fontSize(24).fontColor(Color.White)
              .onClick(() => {
                promptAction.showToast({ message: "æ›´å¤šèœå•å¾…å®ç°" });
              })
          }
        }
        .width('100%').height(50).padding({ left: 16, right: 16 })
        .backgroundColor(this.currentTheme.primaryColor)

        Scroll() {
          Column({ space: 12 }) {
            ForEach(this.todoCollections, (collection: LocalTodoCollection) => {
        Column() {
          Row() {
                  Text(collection.collectionTitle)
                      .fontSize(18)
                      .fontWeight(FontWeight.Bold)
                    .fontColor(collection.isSequenceActive ? '#FFA500' : this.currentTheme.textColor)
                    .layoutWeight(1)
                    .onClick(() => {
                      this.toggleExpand(collection);
                    })

                  Text(collection.isExpanded ? "ğŸ”¼" : "ğŸ”½")
                      .width(24)
                      .height(24)
                    .fontSize(18)
                    .textAlign(TextAlign.Center)
                    .margin({ left: 8 })
                    .onClick(() => {
                      this.toggleExpand(collection);
                    })

                  Button(collection.isSequenceActive ? 'åºåˆ—è¿›è¡Œä¸­...' : 
                    (collection.subTasks.every(st => st.isCompleted) ? 'é‡æ–°å¼€å§‹åºåˆ—' : 'å¼€å§‹åºåˆ—'))
                    .fontSize(14)
                    .fontColor(Color.White)
                    .backgroundColor(collection.isSequenceActive ? '#FFA500' : '#1E90FF')
                    .borderRadius(12)
                    .height(32)
                    .padding({ left: 8, right: 8 })
                    .margin({ left: 10 })
                    .enabled(!collection.isSequenceActive)
                    .onClick(() => {
                      // å¦‚æœæ‰€æœ‰ä»»åŠ¡éƒ½å·²å®Œæˆï¼Œé‡ç½®æ‰€æœ‰ä»»åŠ¡çŠ¶æ€
                      if (collection.subTasks.every(st => st.isCompleted)) {
                        collection.subTasks.forEach(st => st.isCompleted = false);
                        // æ›´æ–°UI
                        const colIndex = this.todoCollections.findIndex(c => c.id === collection.id);
                        if (colIndex !== -1) {
                          const updatedCollection = new LocalTodoCollection(
                            collection.id, 
                            collection.collectionTitle, 
                            collection.subTasks,
                            collection.isExpanded
                          );
                          updatedCollection.isSequenceActive = collection.isSequenceActive;
                          updatedCollection.currentTaskIndex = collection.currentTaskIndex;
                          this.todoCollections.splice(colIndex, 1, updatedCollection);
                          this.todoCollections = Array.from(this.todoCollections);
                        }
                      }
                      this.startSequenceTask(collection, 0);
                    })
                    .visibility(collection.subTasks.length > 0 ? Visibility.Visible : Visibility.Hidden)
                  }
                  .width('100%')
                .padding({
                  top: 10,
                  bottom: 10,
                  left: 10,
                  right: 10
                })
                .backgroundColor(collection.isExpanded ? this.currentTheme.cardBackgroundColor : this.currentTheme.cardBackgroundColor)
                .borderRadius(8)

                if (collection.isExpanded) {
                  Column({ space: 8 }) {
                    ForEach(collection.subTasks, (task: ActualTodoItem) => {
                      Swiper() {
                        Row() {
                          Column() {
                            Text(task.title)
                              .fontSize(16)
                              .fontWeight(FontWeight.Medium)
                              .fontColor(this.currentTheme.textColor)
                            Text(`${task.durationMinutes} åˆ†é’Ÿ`)
                              .fontSize(14)
                              .fontColor(this.currentTheme.textColor)
                              .opacity(0.6)
                              .margin({ top: 4 })
                          }
                          .layoutWeight(1)
                          .alignItems(HorizontalAlign.Start)

                          if (task.isCompleted) {
                            Text('âœ“')
                              .fontSize(20)
                              .fontColor('#4CAF50')
                          } else if (collection.currentTaskIndex === collection.subTasks.indexOf(task) && collection.isSequenceActive) {
                            Text('â³')
                              .fontSize(20)
                              .fontColor('#FFA500')
                          }
                        }
                        .width('100%')
                        .padding(12)
                        .backgroundColor(task.isCompleted ? this.currentTheme.borderColor : this.currentTheme.cardBackgroundColor)
                        .borderRadius(8)
                        .margin({ top: collection.subTasks.indexOf(task) === 0 ? 8 : 0 })
                        .onClick(() => {
                          if (!task.isCompleted && !collection.isSequenceActive) {
                            // å¦‚æœç‚¹å‡»æœªå®Œæˆçš„å­ä»»åŠ¡ï¼Œä»è¯¥ä»»åŠ¡å¼€å§‹åºåˆ—
                            this.startSequenceTask(collection, collection.subTasks.indexOf(task));
                          }
                        })

                        Row() {
                          Button('åˆ é™¤')
                            .width('100%')
                            .height('100%')
                            .backgroundColor(this.currentTheme.errorColor)
                            .fontColor(Color.White)
                            .onClick(() => {
                              // åˆ é™¤å­ä»»åŠ¡
                              const taskIndex = collection.subTasks.indexOf(task);
                              if (taskIndex !== -1) {
                                collection.subTasks.splice(taskIndex, 1);
                                
                                // æ›´æ–°é›†åˆ
                                const index = this.todoCollections.findIndex(c => c.id === collection.id);
                                if (index !== -1) {
                                  const updatedCollection = new LocalTodoCollection(
                                    collection.id,
                                    collection.collectionTitle,
                                    collection.subTasks,
                                    collection.isExpanded
                                  );
                                  updatedCollection.isSequenceActive = collection.isSequenceActive;
                                  updatedCollection.currentTaskIndex = collection.currentTaskIndex;
                                  this.todoCollections.splice(index, 1, updatedCollection);
                                  this.todoCollections = Array.from(this.todoCollections);
                                }
                                
                                promptAction.showToast({ message: "å­ä»»åŠ¡å·²åˆ é™¤" });
                              }
                            })
                        }
                        .width(80)
                        .height('100%')
                        .backgroundColor(this.currentTheme.errorColor)
                        .borderRadius(8)
                      }
                      .index(0)
                      .width('100%')
                      .height(80)
                      .displayMode(SwiperDisplayMode.STRETCH)
                      .itemSpace(0)
                      .indicator(false)
                    })

                    // æ·»åŠ æ–°å­ä»»åŠ¡çš„æŒ‰é’®
                    Button('+ æ·»åŠ å­ä»»åŠ¡')
                      .width('100%')
                      .height(40)
                      .fontSize(14)
                      .fontColor(this.currentTheme.primaryColor)
                      .backgroundColor(this.currentTheme.cardBackgroundColor)
                      .borderRadius(8)
                      .margin({ top: 12 })
                      .onClick(() => {
                        this.currentExpandedId = collection.id;
                        this.openAddSubTaskDialog();
                      })
                  }
                  .width('100%')
                  .padding({
                    left: 8,
                    right: 8,
                    bottom: 8,
                    top: 8
                  })
                  .backgroundColor(this.currentTheme.borderColor)
                  .borderRadius(8)
                  .animation({
                    duration: 250,
                    curve: Curve.EaseInOut,
                    iterations: 1,
                    playMode: PlayMode.Normal
                  })
                }
              }
              .width('100%')
              .backgroundColor(this.currentTheme.cardBackgroundColor)
              .borderRadius(10)
              .padding(12)
              .shadow({
                radius: 3,
                color: 'rgba(0,0,0,0.08)',
                offsetX: 1,
                offsetY: 2
              })
            })
          }
          .width('100%').padding(16)
        }
        .layoutWeight(1)
        
        // åº•éƒ¨å¯¼èˆªæ 
        TabBar({ currentIndex: 1 })
      }
      .width('100%').height('100%')

      if (this.showCongratulationsDialog) {
          Column() {
          // å…¼å®¹å†™æ³•ï¼šå¦‚æœ‰å›¾ç‰‡èµ„æºåˆ™ç”¨å›¾ç‰‡ï¼Œå¦åˆ™ç”¨Emoji
          // Image($r('app.media.congrats')).width(100).height(100).margin({bottom: 15})
          Text("ğŸ‰").fontSize(60).margin({ bottom: 15 }) // ä½¿ç”¨Emojiä½œä¸ºå ä½
          Text('å¤ªæ£’äº†!').fontSize(22).fontWeight(FontWeight.Bold).fontColor(this.currentTheme.textColor).margin({ bottom: 8 })
          Text('ä½ å·²å®Œæˆå½“å‰åˆé›†ä¸­çš„æ‰€æœ‰ä»»åŠ¡!').fontSize(16).fontColor(this.currentTheme.textColor).margin({ bottom: 20 })
          Button('æˆ‘çŸ¥é“äº†')
            .fontSize(16)
            .fontWeight(FontWeight.Medium)
            .width('70%')
            .height(40)
            .backgroundColor(this.currentTheme.primaryColor)
            .fontColor(Color.White)
          .onClick(() => {
              this.showCongratulationsDialog = false;
            })
        }
        .width('85%')
        .padding(25)
        .backgroundColor(this.currentTheme.cardBackgroundColor)
        .borderRadius(20)
        .shadow({
          radius: 10,
          color: 'rgba(0,0,0,0.2)',
          offsetX: 2,
          offsetY: 2
        })
        .alignItems(HorizontalAlign.Center)
        .justifyContent(FlexAlign.Center)
        .markAnchor({ x: '50%', y: '50%' }) // å±…ä¸­æ˜¾ç¤ºçš„å…³é”®
        .position({ x: '50%', y: '50%' })
        .transition(TransitionEffect.opacity(300)
          .combine(TransitionEffect.scale({
            x: 0.7,
            y: 0.7,
            centerX: '50%',
            centerY: '50%'
          })))
        .zIndex(10)
      }
    }
    .width('100%').height('100%')
  }
}