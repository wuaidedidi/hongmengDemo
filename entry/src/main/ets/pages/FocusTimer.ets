import router from '@ohos.router';
import promptAction from '@ohos.promptAction';
import audioPlayer from '../common/AudioPlayer';
import { ApiService, TodoCollectionItem } from '../services/ApiService';

// å®šä¹‰FocusTimeræ¥æ”¶çš„è·¯ç”±å‚æ•°æ¥å£
interface FocusTimerParams {
  time?: number;
  taskTitle?: string;
  title?: string; // å…¼å®¹æ—§çš„
  isSequence?: boolean;
  collectionId?: string;
  subTaskId?: string;
  todoId?: string | number;
  currentSubTaskIndex?: number;
  totalSubTasksInCollection?: number;
}

// å®šä¹‰FocusTimerè¿”å›ç»™è°ƒç”¨é¡µé¢çš„å‚æ•°æ¥å£
interface FocusCompletionParams {
  action?: 'focusCompleted';
  sequenceAction?: 'taskCompleted' | 'sequenceAborted' | 'sequenceCompleted';
  collectionId?: string;
  subTaskId?: string;
  todoId?: string | number;
  currentSubTaskIndex?: number;
}

// ç±»å‹ç”¨äºå®é™…ä¼ é€’ç»™routerçš„å‚æ•°
type RouterParamsObject = Record<string, string | number | boolean>;

// ç”¨äºæ—¥å¿—è¾“å‡ºçš„ç®€åŒ–ä»»åŠ¡ä¿¡æ¯æ¥å£
interface TaskLogInfo {
  id: number;
  title: string;
  completed?: boolean;
  index?: number;
}

// ä¸‹ä¸€ä¸ªä»»åŠ¡å¯¹è¯æ¡†ç»„ä»¶
@CustomDialog
struct NextTaskDialog {
  @State countdown: number = 5;
  private countdownTimer: number = -1;
  controller: CustomDialogController;
  nextItem: TodoCollectionItem = { 
    id: 0, 
    title: '', 
    completed: false, 
    order: 0,
    collectionId: 0,
    createdAt: ''
  };
  nextIndex: number = 0;
  actualTotalTasks: number = 0;
  onStart: () => void = () => {};
  onCancel: () => void = () => {};

  aboutToAppear() {
    this.startCountdown();
  }

  aboutToDisappear() {
    this.clearCountdown();
  }

  startCountdown() {
    console.info('NextTaskDialog: å¼€å§‹5ç§’å€’è®¡æ—¶');
    this.countdownTimer = setInterval(() => {
      this.countdown--;
      console.info(`NextTaskDialog: å€’è®¡æ—¶å‰©ä½™ ${this.countdown} ç§’`);
      if (this.countdown <= 0) {
        console.info('NextTaskDialog: å€’è®¡æ—¶ç»“æŸï¼Œå‡†å¤‡å¼€å§‹ä¸‹ä¸€ä¸ªä»»åŠ¡');
        this.clearCountdown();
        this.onStart();
      }
    }, 1000);
  }

  clearCountdown() {
    if (this.countdownTimer !== -1) {
      clearInterval(this.countdownTimer);
      this.countdownTimer = -1;
    }
  }

  build() {
    Column() {
      // æ ‡é¢˜åŒºåŸŸ
      Column() {
        Text('ğŸ¯')
          .fontSize(48)
          .margin({ top: 20, bottom: 10 })
        Text('å‡†å¤‡ä¸‹ä¸€ä¸ªä»»åŠ¡')
          .fontSize(22)
          .fontWeight(FontWeight.Bold)
          .fontColor('#333')
      }
      .alignItems(HorizontalAlign.Center)

      // ä»»åŠ¡ä¿¡æ¯åŒºåŸŸ
      Column({ space: 12 }) {
        Row() {
          Text('å³å°†å¼€å§‹ï¼š')
            .fontSize(16)
            .fontColor('#666')
          Text(this.nextItem.title)
            .fontSize(16)
            .fontWeight(FontWeight.Medium)
            .fontColor('#333')
            .layoutWeight(1)
            .textAlign(TextAlign.End)
        }
        .width('100%')

        Row() {
          Text('ä¸“æ³¨æ—¶é•¿ï¼š')
            .fontSize(16)
            .fontColor('#666')
          Text('25åˆ†é’Ÿ')
            .fontSize(16)
            .fontWeight(FontWeight.Medium)
            .fontColor('#333')
        }
        .width('100%')
        .justifyContent(FlexAlign.SpaceBetween)

        Row() {
          Text('è¿›åº¦ï¼š')
            .fontSize(16)
            .fontColor('#666')
          Text(`${this.nextIndex + 1}/${this.actualTotalTasks}`)
            .fontSize(16)
            .fontWeight(FontWeight.Medium)
            .fontColor('#007AFF')
        }
        .width('100%')
        .justifyContent(FlexAlign.SpaceBetween)
      }
      .padding({ left: 20, right: 20, top: 16, bottom: 16 })
      .backgroundColor('#F8F9FA')
      .borderRadius(12)
      .margin({ left: 16, right: 16 })

      // å€’è®¡æ—¶åŒºåŸŸ
      Column() {
        Text(`${this.countdown}`)
          .fontSize(48)
          .fontWeight(FontWeight.Bold)
          .fontColor('#007AFF')
        Text('ç§’åè‡ªåŠ¨å¼€å§‹ä¸‹ä¸€ä¸ªä»»åŠ¡')
          .fontSize(14)
          .fontColor('#666')
          .opacity(0.8)
      }
      .margin({ top: 20, bottom: 20 })
      .alignItems(HorizontalAlign.Center)

      // æ“ä½œæŒ‰é’®åŒºåŸŸ
      Row({ space: 12 }) {
        Button('ç»“æŸåºåˆ—')
          .layoutWeight(1)
          .height(44)
          .fontSize(16)
          .fontColor('#FF3B30')
          .backgroundColor('#FFF')
          .border({ width: 1, color: '#FF3B30' })
          .borderRadius(22)
          .onClick(() => {
            this.clearCountdown();
            this.onCancel();
          })

        Button(`ç«‹å³å¼€å§‹`)
          .layoutWeight(1)
          .height(44)
          .fontSize(16)
          .fontColor('#FFF')
          .backgroundColor('#007AFF')
          .borderRadius(22)
          .onClick(() => {
            this.clearCountdown();
            this.onStart();
          })
      }
      .width('100%')
      .padding({ left: 20, right: 20, bottom: 20 })
    }
    .width('92%')
    .backgroundColor('#FFF')
    .borderRadius(20)
    .shadow({ radius: 16, color: 'rgba(0,0,0,0.1)', offsetX: 0, offsetY: 4 })
  }
}

@CustomDialog
struct MusicSelectionDialog {
  @State selectedMusic: string = '';
  controller: CustomDialogController;
  musicOptions: string[] = [];
  onSelectMusic: (music: string) => void = () => {};

  build() {
    Column({ space: 0 }) {
      // é¡¶éƒ¨éŸ³ä¹å›¾æ ‡
      Column() {
        Text('ğŸ¶')
          .fontSize(48)
          .margin({ top: 18, bottom: 6 })
        Text('é€‰æ‹©èƒŒæ™¯éŸ³ä¹')
          .fontSize(20)
          .fontWeight(FontWeight.Bold)
          .fontColor('#333')
          .margin({ bottom: 10 })
      }
      .align(Alignment.Center)

      // éŸ³ä¹é€‰é¡¹å¡ç‰‡
      Column({ space: 10 }) {
        ForEach(this.musicOptions, (music: string) => {
          Row() {
            Text(music)
              .fontSize(17)
              .fontColor(music === this.selectedMusic ? '#8A2BE2' : '#333')
              .fontWeight(music === this.selectedMusic ? FontWeight.Bold : FontWeight.Normal)
            Blank()
            if (music === this.selectedMusic) {
              Text('âœ”').fontSize(20).fontColor('#8A2BE2')
            }
          }
          .padding({ left: 20, right: 20, top: 14, bottom: 14 })
          .backgroundColor(music === this.selectedMusic ? '#F3EFFF' : '#FFF')
          .borderRadius(16)
          .shadow(music === this.selectedMusic ? { radius: 8, color: '#8A2BE220', offsetX: 0, offsetY: 2 } : undefined)
          .onClick(() => {
            this.onSelectMusic(music);
            this.controller.close();
          })
          .margin({ left: 8, right: 8 })
        })
      }
      .width('100%')
      .margin({ top: 8, bottom: 8 })

      // åº•éƒ¨æ“ä½œåŒº
      Row() {
        Button('å–æ¶ˆ')
          .width('100%')
          .height(44)
          .fontSize(17)
          .fontColor('#8A2BE2')
          .backgroundColor('#F5F5F5')
          .borderRadius(22)
          .onClick(() => {
            this.controller.close();
          })
      }
      .padding({ left: 20, right: 20, top: 10, bottom: 10 })
    }
    .width('92%')
    .backgroundColor('#FFF')
    .borderRadius(22)
    .shadow({ radius: 16, color: 'rgba(138,43,226,0.10)', offsetX: 0, offsetY: 4 })
    .padding({ bottom: 8 })
  }
}

@Entry
@Component
struct FocusTimer {
  @State time: number = 0;
  @State isRunning: boolean = false;
  @State title: string = '';
  @State taskTitle: string = '';
  @State todoId: number = 0;
  @State isSequence: boolean = false;
  @State isMusicDialogShow: boolean = false;
  @State selectedMusic: string = 'æ— å£°';
  private timer: number = -1;
  private startTime: Date = new Date();
  private originalTime: number = 0;
  private musicOptions: string[] = ['æ— å£°', 'è½»æŸ”é’¢ç´', 'è‡ªç„¶é›¨å£°', 'æµ·æµªå£°', 'æ£®æ—é¸Ÿé¸£', 'ç™½å™ªéŸ³', 'å†¥æƒ³éŸ³ä¹'];
  private musicDialogController: CustomDialogController = new CustomDialogController({
    builder: MusicSelectionDialog({
      selectedMusic: $selectedMusic, // ä½¿ç”¨ $ è¿›è¡ŒåŒå‘ç»‘å®š
      musicOptions: this.musicOptions,
      onSelectMusic: (music: string) => {
        this.playSelectedMusic(music);
      }
    }),
    autoCancel: true,
    alignment: DialogAlignment.Center
  });
  private apiService: ApiService = ApiService.getInstance();

  aboutToAppear() {
    const params = router.getParams() as FocusTimerParams;
    console.info('FocusTimer received params: ' + JSON.stringify(params));

    if (params) {
      this.time = params.time !== undefined ? Number(params.time) : 25 * 60;
      this.taskTitle =
        params.taskTitle !== undefined ? String(params.taskTitle) : (params.title ? String(params.title) : 'ä¸“æ³¨ä»»åŠ¡');
      this.title = params.title ? String(params.title) : 'ä¸“æ³¨ä»»åŠ¡';
      this.todoId = params.todoId ? Number(params.todoId) : 0;
      this.isSequence = params.isSequence === true;
    }

    if (this.time <= 0) {
      this.time = 25 * 60;
    }

    this.originalTime = this.time;
    this.startTime = new Date();
    this.startTimer();
    if (this.selectedMusic !== 'æ— å£°') {
      this.playSelectedMusic(this.selectedMusic);
    }
  }

  aboutToDisappear() {
    if (this.timer !== -1) {
      clearInterval(this.timer);
      this.timer = -1;
    }
    
    // åœæ­¢éŸ³ä¹æ’­æ”¾
    audioPlayer.stop();
  }
  
  startTimer() {
    if (this.timer === -1) {
      this.isRunning = true;
      this.timer = setInterval(() => {
        if (this.time > 0) {
          this.time--;
        } else {
          this.stopTimer();
          this.handleSessionComplete();
        }
      }, 1000);
    }
  }
  
  stopTimer() {
    if (this.timer !== -1) {
      clearInterval(this.timer);
      this.timer = -1;
      this.isRunning = false;
    }
  }
  
  restartTimer() {
    // åœæ­¢å½“å‰è®¡æ—¶å™¨
    this.stopTimer();
    
    // é‡ç½®æ—¶é—´åˆ°åŸå§‹å€¼
    this.time = this.originalTime;
    
    // é‡æ–°è®°å½•å¼€å§‹æ—¶é—´
    this.startTime = new Date();
    
    // é‡æ–°å¼€å§‹è®¡æ—¶
    this.startTimer();
    
    // æ˜¾ç¤ºæç¤º
    promptAction.showToast({ message: 'â° é‡æ–°å¼€å§‹è®¡æ—¶' });
  }
  
  async handleSessionComplete() {
    try {
      const endTime = new Date();
      const actualDuration = Math.floor((endTime.getTime() - this.startTime.getTime()) / 1000);
      const durationMinutes = Math.round(actualDuration / 60);
      
      console.info('å¼€å§‹ä¿å­˜ä¸“æ³¨è®°å½•ï¼ˆæ­£å¸¸å®Œæˆï¼‰');
      console.info(`ä¸“æ³¨æ—¶é•¿(ç§’): ${actualDuration}`);
      console.info(`ä¸“æ³¨æ—¶é•¿(åˆ†é’Ÿ): ${durationMinutes}`);
      console.info(`å¼€å§‹æ—¶é—´: ${this.startTime.toISOString()}`);
      console.info(`ç»“æŸæ—¶é—´: ${endTime.toISOString()}`);
      console.info(`åŸå§‹ä¸“æ³¨æ—¶é—´: ${this.originalTime}ç§’`);
      console.info(`å‰©ä½™æ—¶é—´: ${this.time}ç§’`);
      
      // å¦‚æœè®¡ç®—å‡ºçš„æ—¶é•¿å¤ªçŸ­ï¼Œä½¿ç”¨åŸå§‹è®¾å®šæ—¶é—´
      const finalDurationMinutes = durationMinutes > 0 ? durationMinutes : Math.round(this.originalTime / 60);
      console.info(`æœ€ç»ˆä¿å­˜çš„æ—¶é•¿(åˆ†é’Ÿ): ${finalDurationMinutes}`);
      
      // æ ¼å¼åŒ–æ—¶é—´ä¸ºåç«¯æœŸæœ›çš„æ ¼å¼ yyyy-MM-dd HH:mm:ss
      const formatDateTime = (date: Date): string => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
      };
      
      // åˆ›å»ºä¸“æ³¨ä¼šè¯è®°å½•
      await this.apiService.createFocusSession({
        durationMinutes: finalDurationMinutes,
        startTime: formatDateTime(this.startTime),
        endTime: formatDateTime(endTime),
        taskDescription: 'ä¸“æ³¨ä¼šè¯'
      });
      
      console.info('ä¸“æ³¨è®°å½•ä¿å­˜æˆåŠŸ');
      
      // æ˜¾ç¤ºåº†ç¥æç¤º
      promptAction.showToast({ message: 'ğŸ‰ ä¸“æ³¨å®Œæˆï¼å¤ªæ£’äº†ï¼' });
      
      // å¦‚æœæ˜¯åºåˆ—ä»»åŠ¡ï¼Œæ£€æŸ¥å¹¶å¤„ç†ä¸‹ä¸€ä¸ªä»»åŠ¡
      if (this.isSequence) {
        await this.handleSequenceProgress();
      } else {
        router.back();
      }
    } catch (error) {
      console.error('ä¿å­˜ä¸“æ³¨è®°å½•å¤±è´¥:', error);
      console.error('é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯è®¤è¯é—®é¢˜
      if (error.message && error.message.includes('401')) {
        promptAction.showToast({ message: 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•' });
      } else if (error.message && error.message.includes('ç½‘ç»œ')) {
        promptAction.showToast({ message: 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ' });
      } else {
        promptAction.showToast({ message: `ä¿å­˜ä¸“æ³¨è®°å½•å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}` });
      }
    }
  }
  
  async handleEarlyCompletion() {
    try {
      const endTime = new Date();
      const actualDuration = Math.floor((endTime.getTime() - this.startTime.getTime()) / 1000);
      const durationMinutes = Math.round(actualDuration / 60);
      
      console.info('å¼€å§‹ä¿å­˜ä¸“æ³¨è®°å½•ï¼ˆæå‰å®Œæˆï¼‰');
      console.info(`ä¸“æ³¨æ—¶é•¿(ç§’): ${actualDuration}`);
      console.info(`ä¸“æ³¨æ—¶é•¿(åˆ†é’Ÿ): ${durationMinutes}`);
      console.info(`å¼€å§‹æ—¶é—´: ${this.startTime.toISOString()}`);
      console.info(`ç»“æŸæ—¶é—´: ${endTime.toISOString()}`);
      console.info(`åŸå§‹ä¸“æ³¨æ—¶é—´: ${this.originalTime}ç§’`);
      console.info(`å‰©ä½™æ—¶é—´: ${this.time}ç§’`);
      
      // æå‰å®Œæˆæ—¶ï¼Œä½¿ç”¨å®é™…æ—¶é•¿ï¼Œä½†è‡³å°‘1åˆ†é’Ÿ
      const finalDurationMinutes = Math.max(1, durationMinutes);
      console.info(`æœ€ç»ˆä¿å­˜çš„æ—¶é•¿(åˆ†é’Ÿ): ${finalDurationMinutes}`);
      
      // æ ¼å¼åŒ–æ—¶é—´ä¸ºåç«¯æœŸæœ›çš„æ ¼å¼ yyyy-MM-dd HH:mm:ss
      const formatDateTime = (date: Date): string => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
      };
      
      // åˆ›å»ºä¸“æ³¨ä¼šè¯è®°å½•ï¼ˆæå‰å®Œæˆï¼‰
      await this.apiService.createFocusSession({
        durationMinutes: finalDurationMinutes,
        startTime: formatDateTime(this.startTime),
        endTime: formatDateTime(endTime),
        taskDescription: 'ä¸“æ³¨ä¼šè¯ï¼ˆæå‰å®Œæˆï¼‰'
      });
      
      console.info('ä¸“æ³¨è®°å½•ä¿å­˜æˆåŠŸ');
      
      // æ˜¾ç¤ºåº†ç¥æç¤º
      promptAction.showToast({ message: 'ğŸ‰ æå‰å®Œæˆï¼çœŸæ˜¯å¤ªæ£’äº†ï¼' });
      
      // å¦‚æœæ˜¯åºåˆ—ä»»åŠ¡ï¼Œæ£€æŸ¥å¹¶å¤„ç†ä¸‹ä¸€ä¸ªä»»åŠ¡
      if (this.isSequence) {
        await this.handleSequenceProgress();
      } else {
        router.back();
      }
    } catch (error) {
      console.error('ä¿å­˜ä¸“æ³¨è®°å½•å¤±è´¥:', error);
      console.error('é”™è¯¯è¯¦æƒ…:', JSON.stringify(error));
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯è®¤è¯é—®é¢˜
      if (error.message && error.message.includes('401')) {
        promptAction.showToast({ message: 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•' });
      } else if (error.message && error.message.includes('ç½‘ç»œ')) {
        promptAction.showToast({ message: 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ' });
      } else {
        promptAction.showToast({ message: `ä¿å­˜ä¸“æ³¨è®°å½•å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}` });
      }
    }
  }
  
  formatTime(seconds: number): string {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  }
  
  // æ’­æ”¾é€‰æ‹©çš„éŸ³ä¹
  playSelectedMusic(music: string) {
    this.selectedMusic = music;
    try {
      if (music === 'æ— å£°') {
        audioPlayer.stop();
        promptAction.showToast({
          message: 'å·²åˆ‡æ¢åˆ°é™éŸ³æ¨¡å¼',
          duration: 2000
        });
      } else {
        audioPlayer.play(music); // ç›´æ¥ä¼ éŸ³ä¹å
        promptAction.showToast({
          message: `æ­£åœ¨æ’­æ”¾: ${music}`,
          duration: 2000
        });
      }
    } catch (error) {
      console.error(`æ’­æ”¾éŸ³ä¹å¤±è´¥: ${error}`);
      promptAction.showToast({
        message: 'æ’­æ”¾éŸ³ä¹å¤±è´¥ï¼Œè¯·é‡è¯•',
        duration: 2000
      });
    }
  }
  
  // å¤„ç†åºåˆ—ä»»åŠ¡è¿›åº¦
  async handleSequenceProgress(): Promise<void> {
    const params = router.getParams() as FocusTimerParams;
    console.info('å¼€å§‹å¤„ç†åºåˆ—ä»»åŠ¡è¿›åº¦ï¼Œå‚æ•°:', JSON.stringify(params));
    
    if (!params.collectionId || params.currentSubTaskIndex === undefined || params.totalSubTasksInCollection === undefined) {
      console.error('åºåˆ—ä»»åŠ¡å‚æ•°ä¸å®Œæ•´:', params);
      promptAction.showToast({ message: 'åºåˆ—ä»»åŠ¡å‚æ•°é”™è¯¯' });
      router.back();
      return;
    }

    try {
      console.info(`å¼€å§‹å¤„ç†åºåˆ—ä»»åŠ¡ - åˆé›†ID: ${params.collectionId}, å½“å‰ç´¢å¼•: ${params.currentSubTaskIndex}, æ€»æ•°: ${params.totalSubTasksInCollection}`);
      
      // å…ˆè·å–æœ€æ–°çš„å­ä»»åŠ¡åˆ—è¡¨ï¼ˆåœ¨æ›´æ–°çŠ¶æ€ä¹‹å‰ï¼‰
      console.info(`è·å–åˆé›†${params.collectionId}çš„æ‰€æœ‰å­ä»»åŠ¡`);
      const collectionItems = await this.apiService.getCollectionItems(Number(params.collectionId));
      const taskLogInfos: TaskLogInfo[] = collectionItems.map((item: TodoCollectionItem): TaskLogInfo => {
        return { id: item.id, title: item.title, completed: item.completed };
      });
      console.info(`è·å–åˆ°${collectionItems.length}ä¸ªå­ä»»åŠ¡:`, taskLogInfos);
      
      // éªŒè¯å½“å‰ä»»åŠ¡ç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
      if (params.currentSubTaskIndex >= collectionItems.length) {
        console.error(`å½“å‰ä»»åŠ¡ç´¢å¼•${params.currentSubTaskIndex}è¶…å‡ºèŒƒå›´ï¼Œå®é™…ä»»åŠ¡æ•°: ${collectionItems.length}`);
        promptAction.showToast({ message: 'å½“å‰ä»»åŠ¡ç´¢å¼•è¶…å‡ºèŒƒå›´' });
        router.back();
        return;
      }
      
      // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä¸‹ä¸€ä¸ªä»»åŠ¡
      const nextIndex = params.currentSubTaskIndex + 1;
      console.info(`ä¸‹ä¸€ä¸ªä»»åŠ¡ç´¢å¼•: ${nextIndex}, æ€»ä»»åŠ¡æ•°: ${collectionItems.length}`);
      
      // æ ‡è®°å½“å‰å­ä»»åŠ¡ä¸ºå®Œæˆï¼ˆåœ¨ç¡®è®¤æœ‰æ•ˆæ€§åï¼‰
      if (params.subTaskId) {
        console.info(`æ ‡è®°å­ä»»åŠ¡${params.subTaskId}ä¸ºå®Œæˆ`);
        try {
          await this.apiService.toggleCollectionItemStatus(Number(params.collectionId), Number(params.subTaskId));
          console.info('å­ä»»åŠ¡çŠ¶æ€æ›´æ–°æˆåŠŸ');
        } catch (statusError) {
          console.error('æ›´æ–°å­ä»»åŠ¡çŠ¶æ€å¤±è´¥:', statusError);
          // çŠ¶æ€æ›´æ–°å¤±è´¥ä¸åº”è¯¥é˜»æ­¢åºåˆ—ç»§ç»­
        }
      }
      
      if (nextIndex >= collectionItems.length) {
        // æ‰€æœ‰ä»»åŠ¡éƒ½å®Œæˆäº†ï¼Œæ˜¾ç¤ºç¥è´º
        console.info('æ‰€æœ‰ä»»åŠ¡å·²å®Œæˆï¼Œæ˜¾ç¤ºç¥è´ºå¯¹è¯æ¡†');
        await this.showSequenceCompletionDialog();
        router.back();
        return;
      }
      
      const nextItem = collectionItems[nextIndex];
      const nextTaskLogInfo: TaskLogInfo = { 
        id: nextItem.id, 
        title: nextItem.title, 
        index: nextIndex, 
        completed: nextItem.completed 
      };
      console.info(`ä¸‹ä¸€ä¸ªä»»åŠ¡:`, nextTaskLogInfo);
      
      if (!nextItem) {
        console.error('ä¸‹ä¸€ä¸ªä»»åŠ¡ä¸ºç©º');
        promptAction.showToast({ message: 'æ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªä»»åŠ¡' });
        router.back();
        return;
      }

      // æ˜¾ç¤ºå‡†å¤‡ä¸‹ä¸€ä¸ªä»»åŠ¡çš„å¯¹è¯æ¡†
      console.info('æ˜¾ç¤ºä¸‹ä¸€ä¸ªä»»åŠ¡å‡†å¤‡å¯¹è¯æ¡†');
      await this.showNextTaskDialog(nextItem, nextIndex, params, collectionItems.length);

    } catch (error) {
      console.error('å¤„ç†åºåˆ—ä»»åŠ¡è¿›åº¦å¤±è´¥ï¼Œè¯¦ç»†é”™è¯¯:', error);
      console.error('é”™è¯¯ç±»å‹:', typeof error);
      console.error('é”™è¯¯æ¶ˆæ¯:', (error as Error).message);
      console.error('é”™è¯¯å †æ ˆ:', (error as Error).stack);
      promptAction.showToast({ message: `å¤„ç†ä¸‹ä¸€ä¸ªä»»åŠ¡å¤±è´¥: ${(error as Error).message || 'æœªçŸ¥é”™è¯¯'}` });
      router.back();
    }
  }

  // æ˜¾ç¤ºä¸‹ä¸€ä¸ªä»»åŠ¡å¯¹è¯æ¡†
  showNextTaskDialog(nextItem: TodoCollectionItem, nextIndex: number, currentParams: FocusTimerParams, actualTotalTasks: number): Promise<void> {
    return new Promise((resolve) => {
      const nextTaskDialogController = new CustomDialogController({
        builder: NextTaskDialog({
          nextItem: nextItem,
          nextIndex: nextIndex,
          actualTotalTasks: actualTotalTasks,
          onStart: () => {
            console.info('NextTaskDialog: onStartå›è°ƒè¢«è§¦å‘');
            nextTaskDialogController.close();
            
            // è·³è½¬åˆ°ä¸‹ä¸€ä¸ªä»»åŠ¡çš„FocusTimer
            const nextParams: FocusTimerParams = {
              title: `${nextItem.title}`,
              taskTitle: nextItem.title,
              time: 25 * 60, // é»˜è®¤25åˆ†é’Ÿï¼Œå› ä¸ºApiServiceä¸­çš„TodoCollectionItemæ²¡æœ‰durationMinuteså±æ€§
              isSequence: true,
              collectionId: currentParams.collectionId,
              subTaskId: nextItem.id.toString(),
              currentSubTaskIndex: nextIndex,
              totalSubTasksInCollection: actualTotalTasks // ä½¿ç”¨å®é™…çš„ä»»åŠ¡æ•°é‡
            };

            console.info('NextTaskDialog: å‡†å¤‡è·³è½¬åˆ°ä¸‹ä¸€ä¸ªä»»åŠ¡ï¼Œå‚æ•°:', JSON.stringify(nextParams));

            router.replaceUrl({
              url: 'pages/FocusTimer',
              params: nextParams
            }).then(() => {
              console.info('NextTaskDialog: router.replaceUrl è°ƒç”¨æˆåŠŸ');
              resolve();
            }).catch((error: Error) => {
              console.error('NextTaskDialog: router.replaceUrl è°ƒç”¨å¤±è´¥:', error);
              resolve();
            });
          },
          onCancel: () => {
            console.info('ç”¨æˆ·é€‰æ‹©ç»“æŸåºåˆ—');
            nextTaskDialogController.close();
            router.back();
            resolve();
          }
        }),
        autoCancel: false, // ç¦æ­¢ç‚¹å‡»å¤–éƒ¨å…³é—­
        alignment: DialogAlignment.Center
      });
      
      nextTaskDialogController.open();
    });
  }

  // æ˜¾ç¤ºåºåˆ—å®Œæˆç¥è´ºå¯¹è¯æ¡†
  showSequenceCompletionDialog(): Promise<void> {
    return new Promise((resolve) => {
      AlertDialog.show({
        title: 'ğŸ‰ æ­å–œå®Œæˆï¼',
        message: 'ä½ å·²ç»å®Œæˆäº†æ•´ä¸ªå¾…åŠåˆé›†çš„æ‰€æœ‰ä»»åŠ¡ï¼\n\nåšæŒä¸æ‡ˆçš„åŠªåŠ›å€¼å¾—ç§°èµï¼\nç»§ç»­ä¿æŒè¿™ç§ä¸“æ³¨å’Œæ¯…åŠ›ï¼',
        primaryButton: {
          value: 'å¤ªæ£’äº†ï¼',
          action: () => {
            promptAction.showToast({ message: 'ğŸ† æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼ä½ çœŸæ˜¯å¤ªå‰å®³äº†ï¼' });
            resolve();
          }
        }
      });
    });
  }
  
  build() {
    Stack() {
      // èƒŒæ™¯æ¸å˜
      Column()
        .width('100%')
        .height('100%')
        .linearGradient({
          angle: 180,
          colors: [['#333355', 0.0], ['#503060', 0.3], ['#803070', 0.7], ['#8A2BE2', 1.0]]
        })
      
      // ä¸»å†…å®¹
      Column() {
        // é¡¶éƒ¨åŒºåŸŸ
        Row() {
          Text(this.title)
            .fontSize(24)
            .fontWeight(FontWeight.Bold)
            .margin({ top: 20, bottom: 10 })
          
          Blank()
          
          if (this.isSequence) {
            Text(`åºåˆ—ä»»åŠ¡ ${this.time / 60}åˆ†é’Ÿ`)
              .fontSize(16)
              .fontColor('#FFFFFF')
              .opacity(0.8)
              .margin({ right: 16 })
          }
          
          Row({ space: 4 }) {
            Text('ğŸ“·')
              .fontSize(24)
              .fontColor('#FFFFFF')
            Text('â§‰')
              .fontSize(24)
              .fontColor('#FFFFFF')
            Text('â†—')
              .fontSize(24)
              .fontColor('#FFFFFF')
            Text('â¬‡')
              .fontSize(24)
              .fontColor('#FFFFFF')
          }
          .margin({ right: 16 })
        }
        .width('100%')
        .height(60)
        
        // å¼•ç”¨åŒºåŸŸ
        Row() {
          Text('"')
            .fontSize(60)
            .fontColor('#FFFFFF')
            .opacity(0.5)
            .margin({ top: -30 })
          
          Column() {
            Text(this.taskTitle)
              .fontSize(22)
              .fontColor('#FFFFFF')
              .fontWeight(FontWeight.Medium)
              .margin({ top: 30 })
          }
          .layoutWeight(1)
        }
        .width('100%')
        .margin({ top: 16, bottom: 32 })
        .padding({ left: 16, right: 16 })
        
        // å€’è®¡æ—¶åŒºåŸŸ
        Column() {
          Stack() {
            Circle()
              .width(300)
              .height(300)
              .fill('transparent')
              .stroke('#FFFFFF')
              .strokeWidth(8)
              .opacity(0.5)
            
            Text(this.formatTime(this.time))
              .fontSize(80)
              .fontColor('#FFFFFF')
              .fontWeight(FontWeight.Medium)
          }
          .margin({ top: 40, bottom: 40 })
          
          // æç¤ºæ–‡æœ¬
          Text('ç‚¹å‡»å¼€å§‹æŒ‰é’®æ¥ä¸“æ³¨è®¡æ—¶')
            .fontSize(18)
            .fontColor('#FFFFFF')
            .opacity(0.8)
          
          Text(`${this.isRunning ? 'è¿›è¡Œä¸­' : 'å·²æš‚åœ'} Â· ${this.selectedMusic}`)
            .fontSize(16)
            .fontColor('#FFFFFF')
            .opacity(0.6)
            .margin({ top: 8 })
        }
        .layoutWeight(1)
        .width('100%')
        .justifyContent(FlexAlign.Center)
        
        // åº•éƒ¨æ§åˆ¶æ 
        Row() {
          Button({ type: ButtonType.Circle, stateEffect: true }) {
            Text('ğŸŒ™')
              .fontSize(24)
              .fontColor('#FFFFFF')
          }
          .width(50)
          .height(50)
          .backgroundColor('rgba(255, 255, 255, 0.2)')
          
          Button({ type: ButtonType.Circle, stateEffect: true }) {
            Text('ğŸµ')
              .fontSize(24)
              .fontColor('#FFFFFF')
          }
          .width(50)
          .height(50)
          .backgroundColor('rgba(255, 255, 255, 0.2)')
          .onClick(() => {
            this.isMusicDialogShow = true;
          })
          
          Button({ type: ButtonType.Circle, stateEffect: true }) {
            Text(this.isRunning ? 'â¸' : 'â–¶')
              .fontSize(30)
              .fontColor('#FFFFFF')
          }
          .width(70)
          .height(70)
          .backgroundColor('rgba(255, 255, 255, 0.3)')
          .margin({ left: 16, right: 16 })
          .onClick(() => {
            if (this.isRunning) {
              this.stopTimer();
            } else {
              this.startTimer();
            }
          })
          
          Button({ type: ButtonType.Circle, stateEffect: true }) {
            Text('âœ“')
              .fontSize(24)
              .fontColor('#FFFFFF')
          }
          .width(50)
          .height(50)
          .backgroundColor('rgba(255, 255, 255, 0.2)')
          .onClick(() => {
            this.stopTimer();
            this.handleEarlyCompletion();
          })
          
          Button({ type: ButtonType.Circle, stateEffect: true }) {
            Text('ğŸ”„')
              .fontSize(24)
              .fontColor('#FFFFFF')
          }
          .width(50)
          .height(50)
          .backgroundColor('rgba(255, 255, 255, 0.2)')
          .onClick(() => {
            this.restartTimer();
          })
        }
        .width('100%')
        .justifyContent(FlexAlign.Center)
        .margin({ bottom: 30 })
        
        Text('â†“')
          .fontSize(24)
          .fontColor('#FFFFFF')
          .margin({ bottom: 24 })
          .onClick(() => {
            // åœæ­¢éŸ³ä¹
            audioPlayer.stop();
            router.back();
          })
      }
      .width('100%')
      .height('100%')
      
      // éŸ³ä¹é€‰æ‹©å¯¹è¯æ¡†
      if (this.isMusicDialogShow) {
        Column() {
          Column() {
            // æ ‡é¢˜
            Text('é€‰æ‹©èƒŒæ™¯éŸ³ä¹')
              .fontSize(20)
              .fontWeight(FontWeight.Bold)
              .margin({ top: 20, bottom: 16 })
            
            // éŸ³ä¹é€‰é¡¹åˆ—è¡¨
            List() {
              ForEach(this.musicOptions, (music: string) => {
                ListItem() {
                  Row() {
                    Text(music)
                      .fontSize(18)
                      .fontColor(this.selectedMusic === music ? '#8A2BE2' : '#333333')
                      .fontWeight(this.selectedMusic === music ? FontWeight.Bold : FontWeight.Normal)
                    
                    Blank()
                    
                    if (this.selectedMusic === music) {
                      Text('âœ“')
                        .fontSize(18)
                        .fontColor('#8A2BE2')
                    }
                  }
                  .width('100%')
                  .padding({ left: 20, right: 20, top: 12, bottom: 12 })
                  .onClick(() => {
                    this.playSelectedMusic(music);
                    this.isMusicDialogShow = false;
                  })
                }
              })
            }
            .width('100%')
            .margin({ bottom: 20 })
            
            // å–æ¶ˆæŒ‰é’®
            Button('å–æ¶ˆ')
              .width('80%')
              .height(45)
              .fontSize(16)
              .fontColor('#FFFFFF')
              .backgroundColor('#8A2BE2')
              .borderRadius(22)
              .margin({ bottom: 20 })
              .onClick(() => {
                this.isMusicDialogShow = false;
              })
          }
          .width('85%')
          .borderRadius(16)
          .backgroundColor('#FFFFFF')
          .alignItems(HorizontalAlign.Center)
        }
        .width('100%')
        .height('100%')
        .backgroundColor('rgba(0, 0, 0, 0.5)')
        .justifyContent(FlexAlign.Center)
        .onClick(() => {
          // ç‚¹å‡»èƒŒæ™¯å…³é—­å¯¹è¯æ¡†
          this.isMusicDialogShow = false;
        })
      }
    }
    .width('100%')
    .height('100%')
  }
}

interface FocusTimerRouterParams {
  title: string;
  taskTitle: string;
  time: number;
  todoId: number;
  isSequence: boolean;
}