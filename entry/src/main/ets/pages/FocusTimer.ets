import router from '@ohos.router';
import promptAction from '@ohos.promptAction';
import audioPlayer from '../common/AudioPlayer';

// å®šä¹‰FocusTimeræ¥æ”¶çš„è·¯ç”±å‚æ•°æ¥å£
interface FocusTimerParams {
  time?: number;
  taskTitle?: string;
  title?: string; // å…¼å®¹æ—§çš„
  isSequence?: boolean;
  collectionId?: string;
  subTaskId?: string;
  todoId?: string | number;
  currentSubTaskIndex?: number;
  totalSubTasksInCollection?: number;
}

// å®šä¹‰FocusTimerè¿”å›ç»™è°ƒç”¨é¡µé¢çš„å‚æ•°æ¥å£
interface FocusCompletionParams {
  action?: 'focusCompleted';
  sequenceAction?: 'taskCompleted' | 'sequenceAborted';
  collectionId?: string;
  subTaskId?: string;
  todoId?: string | number;
  currentSubTaskIndex?: number;
}

// ç±»å‹ç”¨äºå®é™…ä¼ é€’ç»™routerçš„å‚æ•°
type RouterParamsObject = Record<string, string | number | boolean>;

@CustomDialog
struct MusicSelectionDialog {
  @State selectedMusic: string = '';
  controller: CustomDialogController;
  musicOptions: string[] = [];
  onSelectMusic: (music: string) => void = () => {};

  build() {
    Column({ space: 0 }) {
      // é¡¶éƒ¨éŸ³ä¹å›¾æ ‡
      Column() {
        Text('ğŸ¶')
          .fontSize(48)
          .margin({ top: 18, bottom: 6 })
        Text('é€‰æ‹©èƒŒæ™¯éŸ³ä¹')
          .fontSize(20)
          .fontWeight(FontWeight.Bold)
          .fontColor('#333')
          .margin({ bottom: 10 })
      }
      .align(Alignment.Center)

      // éŸ³ä¹é€‰é¡¹å¡ç‰‡
      Column({ space: 10 }) {
        ForEach(this.musicOptions, (music: string) => {
          Row() {
            Text(music)
              .fontSize(17)
              .fontColor(music === this.selectedMusic ? '#8A2BE2' : '#333')
              .fontWeight(music === this.selectedMusic ? FontWeight.Bold : FontWeight.Normal)
            Blank()
            if (music === this.selectedMusic) {
              Text('âœ”').fontSize(20).fontColor('#8A2BE2')
            }
          }
          .padding({ left: 20, right: 20, top: 14, bottom: 14 })
          .backgroundColor(music === this.selectedMusic ? '#F3EFFF' : '#FFF')
          .borderRadius(16)
          .shadow(music === this.selectedMusic ? { radius: 8, color: '#8A2BE220', offsetX: 0, offsetY: 2 } : undefined)
          .onClick(() => {
            this.onSelectMusic(music);
            this.controller.close();
          })
          .margin({ left: 8, right: 8 })
        })
      }
      .width('100%')
      .margin({ top: 8, bottom: 8 })

      // åº•éƒ¨æ“ä½œåŒº
      Row() {
        Button('å–æ¶ˆ')
          .width('100%')
          .height(44)
          .fontSize(17)
          .fontColor('#8A2BE2')
          .backgroundColor('#F5F5F5')
          .borderRadius(22)
          .onClick(() => {
            this.controller.close();
          })
      }
      .padding({ left: 20, right: 20, top: 10, bottom: 10 })
    }
    .width('92%')
    .backgroundColor('#FFF')
    .borderRadius(22)
    .shadow({ radius: 16, color: 'rgba(138,43,226,0.10)', offsetX: 0, offsetY: 4 })
    .padding({ bottom: 8 })
  }
}

@Entry
@Component
struct FocusTimer {
  @State minutes: number = 0;
  @State seconds: number = 0;
  @State totalSeconds: number = 0;
  @State isPaused: boolean = false;
  @State quote: string = 'ä¸“æ³¨çš„æ—¶å…‰ï¼Œä»·å€¼éå‡¡ã€‚';
  @State displayTaskTitle: string = 'ä¸“æ³¨ä»»åŠ¡';
  @State isMusicDialogShow: boolean = false;
  @State selectedMusic: string = 'æ— å£°';
  private timerId: number = -1;
  private musicOptions: string[] = ['æ— å£°', 'è½»æŸ”é’¢ç´', 'è‡ªç„¶é›¨å£°', 'æµ·æµªå£°', 'æ£®æ—é¸Ÿé¸£', 'ç™½å™ªéŸ³', 'å†¥æƒ³éŸ³ä¹'];
  // Router an CustomDialogController should be initialized with proper parameters.
  // Ensure selectedMusic is properly linked if it's meant to be.
  private musicDialogController: CustomDialogController = new CustomDialogController({
    builder: MusicSelectionDialog({
      selectedMusic: $selectedMusic, // ä½¿ç”¨ $ è¿›è¡ŒåŒå‘ç»‘å®š
      musicOptions: this.musicOptions,
      onSelectMusic: (music: string) => {
        this.playSelectedMusic(music);
      }
    }),
    autoCancel: true,
    alignment: DialogAlignment.Center
  });
  @State private isSequence: boolean = false;
  @State private collectionId: string | null = null;
  @State private subTaskId: string | null = null;
  @State private todoId: string | number | null = null;
  @State private currentSubTaskIndex: number = -1;
  @State private totalSubTasksInCollection: number = 0;
  private initialTotalSeconds: number = 25 * 60; // ç”¨äºè¿›åº¦æ¡çš„æ€»æ—¶é•¿

  aboutToAppear() {
    const params = router.getParams() as FocusTimerParams;
    console.info('FocusTimer received params: ' + JSON.stringify(params));

    if (params) {
      this.initialTotalSeconds = params.time !== undefined ? Number(params.time) : 25 * 60;
      this.totalSeconds = this.initialTotalSeconds;
      this.displayTaskTitle =
        params.taskTitle !== undefined ? String(params.taskTitle) : (params.title ? String(params.title) : 'ä¸“æ³¨ä»»åŠ¡');

      this.isSequence = params.isSequence === true;
      this.collectionId = params.collectionId ? String(params.collectionId) : null;
      this.subTaskId = params.subTaskId ? String(params.subTaskId) : null;
      this.todoId = params.todoId ? params.todoId : null;
      this.currentSubTaskIndex = params.currentSubTaskIndex !== undefined ? Number(params.currentSubTaskIndex) : -1;
      this.totalSubTasksInCollection =
        params.totalSubTasksInCollection !== undefined ? Number(params.totalSubTasksInCollection) : 0;
    }

    if (this.totalSeconds <= 0) {
      this.initialTotalSeconds = 25 * 60;
      this.totalSeconds = this.initialTotalSeconds;
    }
    this.minutes = Math.floor(this.totalSeconds / 60);
    this.seconds = this.totalSeconds % 60;

    this.startTimer();
    if (this.selectedMusic !== 'æ— å£°') {
      this.playSelectedMusic(this.selectedMusic, false);
    }
  }

  aboutToDisappear() {
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
    audioPlayer.stop();
  }

  startTimer() {
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
    }
    this.isPaused = false;
    this.timerId = setInterval(() => {
      if (!this.isPaused) {
        if (this.totalSeconds > 0) {
          this.totalSeconds--;
          this.minutes = Math.floor(this.totalSeconds / 60);
          this.seconds = this.totalSeconds % 60;
        } else {
          clearInterval(this.timerId);
          this.timerId = -1;
          audioPlayer.stop();
          this.handleTimerCompletion();
        }
      }
    }, 1000);
  }

  handleTimerCompletion() {
    promptAction.showToast({ message: 'ä¸“æ³¨æ—¶é—´åœ†æ»¡ç»“æŸï¼' });
    let paramsToSend: RouterParamsObject = {};

    if (this.isSequence) {
      paramsToSend['sequenceAction'] = 'taskCompleted';
      if (this.collectionId !== null) {
        paramsToSend['collectionId'] = this.collectionId;
      }
      if (this.subTaskId !== null) {
        paramsToSend['subTaskId'] = this.subTaskId;
      }
      if (this.currentSubTaskIndex !== -1) {
        paramsToSend['currentSubTaskIndex'] = this.currentSubTaskIndex;
      }

      router.replaceUrl({ url: 'pages/TodoDetail', params: paramsToSend })
        .catch((err: Error) => console.error("Failed to navigate for sequence completion: " + JSON.stringify(err)));
    } else {
      paramsToSend['action'] = 'focusCompleted';
      if (this.todoId !== null) {
        paramsToSend['todoId'] = typeof this.todoId === 'number' ? this.todoId.toString() : this.todoId;
        router.replaceUrl({ url: 'pages/Index', params: paramsToSend })
          .catch((err: Error) => console.error("Failed to navigate to Index for completion: " + JSON.stringify(err)));
      } else if (this.collectionId !== null && this.subTaskId !== null) {
        if (this.collectionId !== null) {
          paramsToSend['collectionId'] = this.collectionId;
        }
        if (this.subTaskId !== null) {
          paramsToSend['subTaskId'] = this.subTaskId;
        }
        router.replaceUrl({ url: 'pages/TodoDetail', params: paramsToSend })
          .catch((err: Error) => console.error("Failed to navigate to TodoDetail for completion: " +
          JSON.stringify(err)));
      } else {
        router.back();
      }
    }
  }

  togglePause() {
    this.isPaused = !this.isPaused;
    if (this.isPaused) {
      promptAction.showToast({ message: "è®¡æ—¶å·²æš‚åœ" });
    } else {
      promptAction.showToast({ message: "è®¡æ—¶å·²æ¢å¤" });
    }
  }

  handleExitFocus() {
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
    audioPlayer.stop();
    promptAction.showToast({ message: "ä¸“æ³¨å·²é€€å‡º" });
    let paramsToSend: RouterParamsObject = {};

    if (this.isSequence) {
      paramsToSend['sequenceAction'] = 'sequenceAborted';
      if (this.collectionId !== null) {
        paramsToSend['collectionId'] = this.collectionId;
      }
      if (this.subTaskId !== null) {
        paramsToSend['subTaskId'] = this.subTaskId;
      }

      router.replaceUrl({ url: 'pages/TodoDetail', params: paramsToSend })
        .catch((err: Error) => console.error("Failed to navigate for sequence abort: " + JSON.stringify(err)));
    } else {
      router.back();
    }
  }

  playSelectedMusic(music: string, showToast: boolean = true) {
    this.selectedMusic = music;
    try {
      if (music === 'æ— å£°') {
        audioPlayer.stop();
      } else {
        audioPlayer.play(music);
      }
      if (showToast) {
        promptAction.showToast({
          message: music === 'æ— å£°' ? 'å·²åˆ‡æ¢åˆ°é™éŸ³æ¨¡å¼' : `æ­£åœ¨æ’­æ”¾: ${music}`,
          duration: 2000
        });
      }
    } catch (error) { // Consider more specific error type if possible for audioPlayer
      console.error(`æ’­æ”¾éŸ³ä¹ '${music}' å¤±è´¥: ${JSON.stringify(error)}`);
      if (showToast) {
        promptAction.showToast({ message: 'æ’­æ”¾éŸ³ä¹å¤±è´¥' });
      }
    }
  }

  build() {
    Stack() {
      Column().width('100%').height('100%')
        .linearGradient({
          angle: 180,
          colors: [['#333355', 0.0], ['#503060', 0.3], ['#803070', 0.7], ['#8A2BE2', 1.0]]
        })

      Column() {
        Row() {
          Text(this.isSequence ? `åºåˆ— (${this.currentSubTaskIndex + 1}/${this.totalSubTasksInCollection})` :
            'ä¸“æ³¨æ¨¡å¼')
            .fontSize(18).fontColor('#FFFFFF').margin({ left: 16 }).opacity(0.8)
          Blank()
          // Removed extra icons for now
        }.width('100%').height(50).padding({ top: 10 })

        Column() {
          Text(this.quote)
            .fontSize(20)
            .fontColor('#FFFFFF')
            .fontWeight(FontWeight.Medium)
            .margin({ top: 20 })
            .textAlign(TextAlign.Center)
            .padding({ left: 20, right: 20 }) // Changed paddingSymmetric
        }.width('100%').margin({ bottom: 30 })

        Column() {
          Text(this.displayTaskTitle)
            .fontSize(24)
            .fontColor('#FFFFFF')
            .fontWeight(FontWeight.Bold)
            .margin({ bottom: 20 })
            .padding({ left: 15, right: 15 })// Changed paddingSymmetric
            .textAlign(TextAlign.Center)
            .textOverflow({ overflow: TextOverflow.Ellipsis })
            .maxLines(2)

          Stack() {
            Circle()
              .width(280)
              .height(280)
              .fill('transparent')
              .stroke('#FFFFFF')
              .strokeWidth(6)
              .opacity(0.4)
            Progress({
              value: this.totalSeconds,
              total: this.initialTotalSeconds, // Use initialTotalSeconds for progress total
              type: ProgressType.Ring
            })
              .width(280).height(280).color(Color.White).style({ strokeWidth: 8 })
            Text(`${this.minutes.toString().padStart(2, '0')}:${this.seconds.toString().padStart(2, '0')}`)
              .fontSize(70).fontColor('#FFFFFF').fontWeight(FontWeight.Medium)
          }
          .margin({ top: 20, bottom: 40 })

          Text(`${this.isPaused ? 'å·²æš‚åœ' :
            (this.timerId === -1 && this.totalSeconds <= 0 ? 'å·²å®Œæˆ' : 'è¿›è¡Œä¸­')} Â· ${this.selectedMusic}`)
            .fontSize(16).fontColor('#FFFFFF').opacity(0.7).margin({ top: 8 })
        }
        .layoutWeight(1).width('100%').justifyContent(FlexAlign.Center)

        Row({ space: 20 }) {
          Button({ type: ButtonType.Circle, stateEffect: true }) {
            Text('ğŸµ').fontSize(24)
          }.width(60).height(60).backgroundColor('rgba(255,255,255,0.2)')
          .onClick(() => {
            this.isMusicDialogShow = true;
            this.musicDialogController.open();
          })

          Button({ type: ButtonType.Circle, stateEffect: true }) {
            Text(this.isPaused ? 'â–¶' : 'âšâš').fontSize(28).fontColor("#800080")/* Purple */.fontWeight(FontWeight.Bold)
          }
          .width(80)
          .height(80)
          .backgroundColor(Color.White)
          .onClick(() => {
            this.togglePause();
          })
          .enabled(this.totalSeconds > 0 || this.timerId !== -1)

          Button({ type: ButtonType.Circle, stateEffect: true }) {
            Text('âœ“').fontSize(24)
          }
          .width(60)
          .height(60)
          .backgroundColor('rgba(255,255,255,0.2)')
          .onClick(() => {
            if (this.timerId !== -1) {
              clearInterval(this.timerId);
              this.timerId = -1;
              this.totalSeconds = 0;
              this.minutes = 0;
              this.seconds = 0;
              audioPlayer.stop();
              promptAction.showToast({ message: "æå‰å®Œæˆä¸“æ³¨ï¼" });
              this.handleTimerCompletion();
            }
          })
          .visibility(this.totalSeconds > 0 || this.timerId !== -1 ? Visibility.Visible : Visibility.Hidden)

          Button({ type: ButtonType.Circle, stateEffect: true }) {
            Text('âœ•').fontSize(24)
          }
          .width(60)
          .height(60)
          .backgroundColor('rgba(255,255,255,0.2)')
          .onClick(() => {
            this.handleExitFocus();
          })
          .visibility(this.totalSeconds > 0 || this.timerId !== -1 ? Visibility.Visible : Visibility.Hidden)
        }
        .width('100%').padding(20).justifyContent(FlexAlign.Center).margin({ bottom: 30 })
      }
      .width('100%').height('100%').padding({ top: 10 })
    }
  }
} 